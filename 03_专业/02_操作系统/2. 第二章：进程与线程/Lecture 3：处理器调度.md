---
title: Lecture 3：处理器调度
tags:
  - 操作系统
categories: 
date: 2024-03-18
---
---
## 3.1 调度的基本概念
### 3.1.1 基本概念
**什么是调度**
+ 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理；
+ 这就需要确定某种规则来决定处理这些任务的顺序，这就是**调用**研究的问题；

**处理机调度**
+ 就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。
+ 补充：调度的对象
	+ *对于支持线程的操作系统，操作系统实际调度的是内核级线程而非进程。不过，术语进程调度 （processscheduling）或线程调度 （thread scheduling）常常交替使用*

### 3.1.2 三个层次
**什么是作业**
+ 作业 = 一个具体的任务；
+ 用户向系统提交一个作业 = 用户让操作系统启动一个程序 （来处理一个具体的任务）；

**高级调度 （作业调度）**
+ 概念： 
	+ 按一定的原则从**外存上处于后备队列的作业**中挑选一个（或多个）**作业**，给它们分配内存等必要资源，并建立相应的进程（建立 PCB），以使它 （们）获得竞争处理机的权利；
+ 过程：
	+ 外存 -> 内存；
	+ 面向作业，使得进程完成从**创建态->就绪态**；
+ **说明：**
	+ 高级调度是辅存 （外存）与内存之间的调度。
	+ 每个作业只调入一次，调出一次。
	+ 作业调入时会**建立相应的 PCB，作业调出时才撤销 PCB**。
	+ 高级调度主要指**调入**的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
+ 图示：
	+ ![[Pasted image 20240317235236.png]]

**中级调度 （内存调度）** 
+ 概念：  
	+ 1. 决定将**哪个处于挂起状态的进程**重新调入**内存**；
	+ 2. 将内存中长期处于阻塞状态或者不运行的进程从内存挂起到外存，**节省内存空间**；
+ 过程：
	+ 外存 -> 内存；
	+ 面向进程；
+ 特点：
	+ 一个进程可能会被多次调出，调入内存，因此中级调度发生的频率要比高级调度更高；
+ 图示：
	+ ![[Pasted image 20240317235257.png]]

**低级调度 （进程调度）**  
+ 概念：
	+ 其主要任务是按照某种方法和策略从**就绪队列中选取一个进程**，将处理机分配给它。
	+ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度；
+ 特点：
	+ 进程调度的频率很高，一般几十毫秒一次；
+ 过程：
	+ 内存 -> CPU；
	+ 面向进程；
+ 图示：
	+ ![[Pasted image 20240317235328.png]]

**三层调度的联系与对比**
![[Pasted image 20240317235342.png]]

### 3.1.3 七状态模型
**挂起**  
+ 概念： 
	+ 挂起胎：suspend
	+ 暂时调到外存等待的进程状态为挂起状态；
+ 两种状态：
	+ 就绪挂起状态
	+ 阻塞挂起状态
+ **挂起** 和 **阻塞** 的区别：
	+ 1. 两种状态都是暂时不能获得 CPU 的服务；
	+ 2. 挂起态是将进程映像调到**外存**；
	+ 3. 阻塞态下进程映像在**内存**中；

**七状态模型**
+ 图示：
	+ ![[Pasted image 20240317235409.png]]

## 3.2 进程调度的概念
### 3.2.1 进程调度切换基本概念
**进程调度切换情况**
+ 进程**主动**放弃处理机：
	+ 1. 进程正常终止；
	+ 2. 运行过程中发生异常而终止；
	+ 3. 进程主动请求阻塞（如等待 I/O）；
+ 进程**被动**放弃处理器：
	+ 1. 分给进程的时间片用完
	+ 2. 有更紧急的事需要处理（如 I/O 中断）；
	+ 3. 有更高优先级的进程进入就绪队列；

**不能进行进程切换的情况**
1. 中断：在**处理中断**的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换；
2. 临界：进程在操作系统**内核程序临界区**中；
3. 原语：在原子操作过程中 （**原语**）。原子操作不可中断，要一气呵成 （如之前讲过的修改 PCB 中进程状态标志，并把 PCB 放到相应队列）；

**临界资源**
+ 一个时间段内只允许一个进程使用的资源；
+ 各进程需要互斥地访问临界资源；

**临界区**
+ 概念：访问临界资源的那段代码。
+ 分类：
	+ 1. 普通临界区；
	+ 2. 内核临界区； 
		+ 内核程序临界区：一般是用来访问某种内核数据结构的，比如进程的就绪队列 （由各就绪进程的 PCB 组成）
+ 注意：
	+ 1. 内核临界区内访问的资源如果长时间得不到释放，影响其他工作；
	+ 2. 因此处于**临界区的进程可以被中断或者抢占进而被调度**。比如请求一个打印机资源时，可以让它放弃 CPU，而让其他进程运行；

### 3.2.2 切换与过程
**狭义的进程调度**与**进程切换**的区别
+ 狭义的进程调度：
	+ 指的是从**就绪队列**中选中一个要运行的进程；
	+ 这个进程可以是刚刚被暂停执行的过程，也可能是另一个进程，后一种情况就是需要进程切换；
+ 进程切换：
	+ 指一个进程让出处理机，由另一个进程占用处理机的过程。
+ 广义的进程调度：
	+ 包含了：**1. 选择进程；2. 进程切换；** 这两个步骤；

**进程切换的过程主要完成了：**
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复

**注意**
+ 进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然会使整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少。

### 3.2.3 调度方式
**非剥夺调度方式**
+ 概念： 
	+ 又称**非抢占**方式：即只允许进程主动放弃处理机。
	+ 在运行过程中即便有更窘迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
+ **特点：**
	+ 实现简单开销小，但是无法及时处理紧急任务，适合于早起的批处理系统
+ 举例：
	+ 非抢占式调度在有些硬件平台上是唯一的方法，因为它不需要特殊硬件 （如定时器）来支持抢占调度；

**剥夺调度方式：**
+ 概念：  
	+ 又称**抢占**方式：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。
+ **特点：**
	+ 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能 （通过时钟中断）；
	+ 缺点：抢占也影响操作系统的内核设计。在处理系统调用时，内核可能为进程而忙于某个活动。这些活动可能涉及改变重要的内核数据；
+ 举例：
	+ Windows 95 引人抢占调度，所有之后的 Windows 操作系统都使用了抢占调度； 
	+ Macintosh 操作系统 MacOSX 采用抢占调度，而之前的 Macintosh 操作系统采用协作调度；

### 3.2.4 调度程序与闲逛进程
**调度程序**
+ 概念：与 CPU 调度功能有关的另一个组件是调度程序 （dispatcher）。调度程序是一个模块，用来将 CPU 控制交给由短期调度程序选择的进程。这个功能包括:切换上下文。
切换到用户模式。
跳转到用户程序的合适位置，以便重新启动程序，调度程序应尽可能快，因为在每次进程切换时都要使用。调度程序停止一个进程而启动另个所需的时间称为调度延迟 （dispatchlatency）。

**调度状态关系**
+ 图示：
	+ ![[Pasted image 20240318005025.png]]
+ 概念： 
	+ 图中的 2、3 由调度程序引起，并且由调度程序控制；
+ 调度内容：
	+ 调度算法与时间片时间；
+ 触发调度程序：
	+ 1. 创建新进程；
	+ 2. 进程退出；
	+ 3. 运行进程阻塞：一个进程从运行状态切换到等待状态时 （例如I/O 请求）；
	+ 4. 发生 IO 中断，此时可能唤醒某个阻塞的进程；
	+ 5. 进程从等待状态切换到就绪状态时 （例如，IO 完成）；
+ 抢占式与非抢占式区别：
	+ 非抢占式：只有运行进程阻塞或者推出才可能触发调度程序工作；
	+ 抢占式：每个时钟中断或 k 个时钟中断会触发调度程序工作；

**闲逛进程**
+ 概念： 
	+ 调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）；
+ 特点：
	+ 1. 优先级最低；
	+ 2. 可以是 0 地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）；
	+ 3. 能耗低；

## 3.3 调度算法的评价指标
**CPU 利用率**
+ 概念：指 CPU 忙碌的时间占总时间的比例；
+ 公式：$\textcolor{red}{利用率}=\frac{\mbox{忙碌的时间}}{\mbox{总时间}}$
+ 注意：可以使用甘特图来进行计算；
+ 补充：对于一个实际系统，它的范围应从 40%（轻负荷系统）到 90%（重负荷系统）；

**系统吞吐量**
+ 概念：单位时间内完成作业的数量；
+ 公式：$\textcolor{red}{系统吞吐量}=\frac{\mbox{总共完成了多少道作业}}{\mbox{总共花了多少时间}}$

**周转时间**
+ 概念：指从**作业提交给系统**开始，到**作业完成**为止花了多少时间。
+ 组成：周转时间为所有时间段之和；
	+ 1. 等待进入内存：作业在外存后备队列上等待作业调度（高级调度）的时间；
	+ 2. 就绪队列中等待：进程在就绪队列上等待进程调度（低级调度）的时间；
	+ 3. 进程在 CPU 上执行的时间
	+ 4. 进程等待 I/O 操作完成的时间
+ 注意：后三项在一个作业的整个处理过程中，可能发生多次；
+ 公式： $周转时间 = 作业完成时间 - 作业提交时间$

**几种周转时间**
+ 公式：$\textcolor{red}{平均周转时间}=\frac{\mbox{各作业周转时间之和}}{\mbox{作业数}}$
+ 公式：$\textcolor{red}{带权周转时间}=\frac{\mbox{作业周转时间}}{\mbox{作业实际运行的时间}}=\frac{\mbox{作业完成时间-作业提交时间}}{\mbox{作业实际运行的时间}}$
+ 公式：$\textcolor{red}{平均带权周转时间}=\frac{\mbox{各作业带权周转时间之和}}{\mbox{作业数}}$

**等待时间**
+ 概念：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低；
+ 图示：
	+ ![[Pasted image 20240318000023.png]]

**响应时间**
+ 概念：指从用户提交请求到首次产生响应所用的时间；

**响应比**
+ 公式：$\textcolor{red}{响应比}=\frac{\mbox{等待时间 + 要求服务时间}}{\mbox{要求服务时间}}$

## 3.4 典型调度算法：非交互式
### 3.4.1 FCFS 算法
**先来先服务**：FCFS（First Come First Serve）
+ **算法思想：**
	+ 主要从**公平**的角度考虑 （类型于我们生活中排队买东西）
+ **算法规则：**
	+ 先请求 CPU 的进程首先分配到 CPU，按照作业/进程到达的先后顺序进行服务；
+ **用于作业/进程调度：**
	+ 用于**作业调度**时，考虑的是哪个作业先到达后备队列；
	+ 用于**进程调度**时，考虑的是哪个进程先到达就绪队列；
+ **是否可抢占**
	+ 一般是非抢占式的；
+ **特点：**
	+ 优点：
		+ 1. 公平；
		+ 2. 算法实现简单；
	+ 缺点：
		+ 1. 用户体验不好：排在长作业 （进程）后面的短作业需要很长时间，带权周转时间很大，对短作业来说用户体验不好；
		+ 2. 对长作业有利，对短作业不利；
		+ 3. FCFS 策略的平均等待时间通常不是最小；
+ **是否会导致饥饿？**
	+ 不会

**举例**
+ 进程图：
	+ ![[Pasted image 20240318005811.png]]
+ 调度图（甘特图）：
	+ ![[Pasted image 20240318005820.png]]
+ 性能计算：
	+ ![[Pasted image 20240318005911.png]]
+ 注意： 
	+ 本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行；
	+ 如果是又有计算、又有 I 0 操作的进程，其等待时间就是$周转时间-运行时间-IO 操作$的时间；

### 3.4.2 SJF 算法与 SRTN 算法
**短作业优先**：SJF（Shortest Job First）
+ 注意：另外一种名字是**最短下次 CPU 执行**（shortest-next-CPU-burst）算法；
+ **算法思想：**
	+ 追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间
+ **算法规则：**
	+ **最短**的作业/进程优先得到服务 （所谓**最短**，是指要求服务时间最短）
	+ 当 CPU 变为空闲时，它会被赋给具有最短 CPU 执行的进程；
	+ 如果两个进程具有同样长度的 CPU 执行，那么可以由 FCFS 来处理；
+ **用于作业/进程调度：**
	+ 即可用于作业调度，也可用于进程调度；
	+ 用于进程调度时称为 `短进程优先（SPF,Shortest Process First）` 算法。
+ **是否可抢占?**
	+ SJF 和 SPF 是非抢占式的算法；
	+ 有抢占式的版本：最短剩余时间优先算法 （SRTN，Shortest Remaining Time Next）
+ **特点：**
	+ 优点：
		+ 1. 大部分情况下**最短的**平均等待时间，平均周转时间；
		+ 2. SJF 调度经常用于**批处理下的长期调度**，因为在这种系统下，用户有意精确估计进程时间；
	+ 缺点：
		+ 1. 不公平：对短作业有利，对长作业不利；
		+ 2. 可能产生饥饿现象。
		+ 3. 作业/进程的运行时间是由用户提供的，并不一定真实（用户故意提交大量短作业），不一定能做到真正的短作业优先；
		+ 4. 不能在短期 CPU 调度级别上加以实现：难以知道下次 CPU 执行的长度；
+ **是否会导致饥饿?**
	+ 会
	+ 如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。
	+ 如果**一直得不到服务，则称为饿死**；
+ 结论：在所有进程都几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少；
	+ SJF 依然可以获得较少的平均等待时间、平均周转时间；

**最短剩余时间优先算法**：SRTN 算法
+ 概念： 
	+ 每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。
	+ 另外，当一个进程完成时也需要调度。
+ 特点：
	+ 平均周转时间最短

**举例**：非抢占式
+ 短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程； 
+ 进程图：
	+ ![[Pasted image 20240318011418.png]]
+ 调度图：
	+ ![[Pasted image 20240318011432.png]]
+ 性能计算： 
	+ ![[Pasted image 20240318011500.png]]

**举例**：抢占式  
+ 使用：最短剩余时间优先算法；
+ 时机：
	+ 1. 每当有进程加入就绪队列改变时就需要调度；
	+ 2. 如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列；
	+ 3. 当一个进程完成时也需要调度；
+ 进程图： 
	+ ![[Pasted image 20240318011555.png]]
+ 调度图：
	+ ![[Pasted image 20240318011836.png]]
+ 运行：
	+ ![[Pasted image 20240318011809.png]]

### 3.4.3 HRRN 算法
**高响应比优先**： HRRN（Highest Response Ratio Next）
+ **算法思想：**
	+ 要综合考虑作业/进程等待时间和要求服务的时间
+ **算法规则：**
	+ 在每次调度时先计算各个作业/进程的相应比，选择相应比最高的作业/进程为其服务
+ **用于作业/进程调度：**
	+ 即可用于作业调度，也可用于进程调度
+ **是否可抢占?**
	+ 非抢占式的算法。
	+ 因此只有当前运行的作业/进程主动放弃 CPU 时，才需要调度，才需要计算响应比
+ **特点：**
	+ 优点：
		+ 综合考虑了等待时间和运行时间 （要求服务时间）
		+ 等待时间相同时，要求服务时间短的优先 （SJF 的优点）
		+ 要求服务时间相同时，等待时间长的优先 （FCFS 的优点）
		+ 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
+ **是否会导致饥饿?**
	+ 不会

**响应比**
+ 公式：$\textcolor{red}{\mbox{响应比}}=\frac{\mbox{等待时间+要求服务的时间}}{\mbox{要求服务时间}}$
+ 注意：响应比一定大于 1；

**举例**
+ 概念：
	+ 只有当前运行的进程主动放弃 CPU 时 （正常/异常完成，或主动阻塞），才需要进行调度； 
	+ 调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机；
+ 进程图：
	+ ![[Pasted image 20240318012733.png]]
+ 运行过程：
	+ ![[Pasted image 20240318012813.png]]
+ 调度图： 
	+ ![[Pasted image 20240318012845.png]]

### 3.4.5 非交互式算法比较
**三种非交互式算法比较**
+ 图示：
	+ ![[Pasted image 20240318000504.png]]
+ 结论：这三种算法交互性糟糕，不区分紧急程度，一般只适用于早起的批处理系统；

## 3.5 典型调度算法：交互式  
### 3.5.1 RR 算法
**时间片轮转**：RR（Round-Robin）
+ **算法思想：**
	+ 公平地，轮流地为各个进程服务，让每个进程在**一定时间间隔内**都可以得到响应；
	+ 使得每个用户可以和系统交互，相比于非交互式算法，改善了人机环境；
+ **算法规则：**
	+ 按照各进程到达就绪队列的顺序，**轮流让各个进程执行一个时间片**（如 100 ms）；
	+ 若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到**就绪队列尾**重新排队；
	+ 就绪队列作为循环队列，CPU 调度程序循环整个就绪队列，为每个进程分配不超过一个时间片的 CPU；
	+ RR 算法的性能很大程度取决于时间片的大小；
+ **用于作业/进程调度：**
	+ 主要用于**进程调度** （只有作业放入内存建立了相应的进程后，才能被分配处理机片）；
+ **是否可抢占?**
	+ 是；
	+ 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法；
	+ 由时钟装置发出**时钟中断**来通知 CPU 时间片已到；
+ **特点：**
	+ 优点：
		+ 1. 公平；
		+ 2. 响应快：适用于分时操作系统
	+ 缺点：
		+ 1. 开销：由于高频率的进程切换，因此有一定开销；
		+ 2. 不区分任务的紧急程度；
+ **是否会导致饥饿?**
	+ 不会
+ 注意：
	+ RR 可以满足用户交互的交互系统。但<u>实时系统</u>还要求对**事件的处理具有优先级，此时 RR 不能应对**，需要使用带有优先级的调度算法；

**举例**
+ 进程图：
	+ ![[Pasted image 20240318152756.png]]
+ 调度图： 时间片大小为 2
	+ ![[Pasted image 20240318153056.png]]
+ 运行过程： 
	+ 0 时刻 （P 1 （5））： 0 时刻只有 P 1 到达就绪队列，让 P 1 上处理机运行一个时间片 
	+ 2 时刻 （P 2 （4）→P 1 （3））： 2 时刻 P 2 到达就绪队列，P 1 运行完一个时间片，被剥夺处理机，重新放到队尾
	+ 4 时刻 （P 1 （3）→P 3 （1）→P 2 （2））： 4 时刻，P 3 到达，先插到就绪队尾，紧接着，P 2 下处理机也插到队尾
	+ 6 时刻 （P 3 （1）→P 2 （2）→P 4 （6）→P 1 （1））： 6 时刻，P 1 时间片用完，下处理机，重新放回就绪队尾，发生调度 
	+ 7 时刻 （P 2 （2）→ P 4 （6） P 1 （1））： 虽然 P 3 的时间片没用完，但是由于 P 3 只需运行 1 个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程 P 2 上处理机。

**关于时间片的大小**
+ 时间片过大：
	+ **时间片太大，使得每个进程都可以在一个时间片内就完成**，则时间片轮转调度算法**退化为先来先服务调度**算法，并且会增大进程响应时间； 
	+ 因此时间片不能太大；
+ 时间片过小：
	+ 进程调度、切换是有时间代价的 （保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会**花大量的时间来处理进程切换**，从而导致实际**用于进程执行的时间比例减少**；
	+ 可见时间片也不能太小（一般来说，设计时间片时要让切换进程的开销占比不超过 1%）；

### 3.5.2 优先级调度算法 
**优先级调度**：Priority-Scheduling
+ **算法思想：**
	+ 需要根据任务的紧急程度来决定处理顺序
+ **算法规则：**
	+ 每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
+ **用于作业/进程调度：**
	+ 既可用于作业调度，也可用于进程调度
	+ 甚至用于 I/O 调度
+ **是否可抢占：**
	+ 抢占式，非抢占式都有；
	+ 区别：
		+ 非抢占式：只需在**进程主动**方式处理机时进行调度即可
		+ 抢占式：需在**就绪队列变化**时，检查是否会发生抢占；
+ **特点：**
	+ 优点：
		+ 用优先级区分紧急程度，重要程度，适用于实时操作系统。
		+ 可灵活地调整对各种作业/进程的偏好程度。
	+ 缺点：
		+ 若源源不断地有高优先级进程到来，则可能导致饥饿（无穷阻塞）
			+ *据说，在 1973 年关闭 MIT 的 IBM 7094 时，发现有一个低优先级进程早在 1967 年就已提交，但是一直未能运行*
			+ 解决方法 -> 老化：老化逐渐增加在系统中等待很长时间的进程的优先级；
+ **是否会导致饥饿?**
	+ 会

**优先调度算法补充**
+ 关于就绪队列：
	+ 就绪队列未必只有一个，可以按照不同优先级来组织；
	+ 另外，也可以把优先级高的进程排在更靠近对头的位置；
+ 根据优先级是否可以动态改变分类：
	+ **静态优先级：** 
		+ 创建进程时确定，之后一直不变；
	+ **动态优先级：**
		+ 创建进程时有一个初始值，之后会根据具体情况动态地调整优先级；

**各类进程优先级判定：**
+ 1. 系统进程优先级高于用户进程；
+ 2. 前台进程优先级高于后台进程；
+ 3. 操作系统**更偏好 I/O 型进程** （或称 I/O 繁忙型进程，IO 设备可以和 CPU 并行运行，所以优先 IO 可以提升资源利用率）；
+ **注意：**
	+ 与 I/O 型进程相对的是计算型进程（或 CPU 繁忙型进程）；
	+ 在两个进程一个 CPU 繁忙、一个 IO 繁忙时，IO 繁忙的优先级通常更高；

**动态优先级调整：**
+ 可以从追求公平，提升资源利用率等角度考虑
+ 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
+ 如果某进程占用处理机运行了很长时间，则可适当降低其优先级
+ 如果发现一个进程频繁地进行 I/O 操作，则可适当提升其优先级

**举例**：非抢占式
+ 进程图：优先数越高，优先级越高
	+ ![[Pasted image 20240318153735.png]]
+ 调度图：
	+ ![[Pasted image 20240318153809.png]]
+ 运行过程： 
	+ 0 时刻 （P 1）：只有 P 1 到达，P 1 上处理机； 
	+ 7 时刻 （P 2、P 3、P 4）: P 1 运行完成主动放弃处理机，其余进程都已到达，P 3 优先级最高，P 3 上处理机； 
	+ 8 时刻 （P 2、P 4）: P 3 完成，P 2、P 4 优先级相同，由于 P 2 先到达，因此 P 2 优先上处理机；
	+ 12 时刻 （P 4）: P 2 完成，就绪队列只剩 P 4，P 4 上处理机。

**举例**：抢占式  
+ 进程图： 
	+ ![[Pasted image 20240318153948.png]]
+ 调度图： 
	+ ![[Pasted image 20240318154002.png]]

### 3.5.3 多级队列调度算法  
**多级队列调度算法** 
+ 概念： 
	+ 将**就绪队列分成多个单独队列**，系统中按**进程类型**设置多个队列，进程创建成功后插入某个队列；
	+ 每个队列有自己的调度算法，比如：前台队列（交互式）可以采用 RR 算法调度，而后台队列（批处理）可以采用 FCFS 算法调度；
	+ 队列之间应有调度，通常采用固定优先级抢占调度；
+ 特点： 
	+ 队列之间可采取**固定优先级**或**时间片**划分；
		+ 固定优先级：高优先级空时低优先级进程才能被调度；
		+ 时间片划分：如三个队列分配时间 50%、40%、10%；
	+ 各队列可采用不同的调度策略，如：系统进程队列采用优先级调度、交互式队列采用 RR 、批处理队列采用 FCFS；
+ 图示： 
	+ 系统进程：优先级最高；
	+ 交互式进程：需要及时交互，所以设定为交互式进程；
	+ 批处理进程；
	+ ![[Pasted image 20240318163456.png]]

### 3.5.4 多级反馈队列调度算法 
**多级反馈队列**
+ **算法思想：**
	+ 对其他调度算法的折中权衡（尤其是对多级队列调度算法的改进）；
	+ 允许进程在不同优先级队列之间迁移，类似 IO 密集型进程以及交互进程可以更好的在高优先级队列上被处理；
	+ 其他方案：在**较低优先级**队列中等待过长的进程会被**移到更高优先级**队列; 
+ **算法规则：**
	+ 1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。
	+ 2. 新进程到达时**先进入第 1 级队列**，按 FCFS 原则排队等待被分配时间片，若**用完时间片进程还未结束**，则进程进入**下一级**队尾。如果此时已经是在最下级的队列，则重新**放回该队尾**。
	+ 3. 只有第 k 级队列为空时，才会为 k+1 级对头的进程分配时间片。
	+ 举例：*每个进程在进人就绪队列后，就被添加到队列 0 内。队列 0 内的每个进程都有 8 ms 的时间片。如果一个进程不能在这一时间片内完成，那么它就被移到队列 1 的尾部。如果队列 0 为空，队列 1 头部的进程会得到一个 16 ms 的时间片。如果它不能完成，那么将被抢占，并添加到队列 2。只有当队列 0 和 1 为空时，队列 2 内的进程才可根据 FCFS 来运行；*
+ **用于作业/进程调度：**
	+ 用于进程调度；
+ **是否可抢占?**
	+ 抢占式的算法。
	+ 在 k 级队列的进程运行过程中，若更上级的队列 （1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。
+ **特点：**
	+ 1. 对各类型进程相对公平 （FCFS 的优点）；
	+ 2. 每个新到达的进程都可以很快就得到响应 （RR 的优点）；
	+ 3. 短进程只用较少的时间就可完成 （SPF 的优点）；
	+ 4. 不必实现估计进程的运行时间 （避免用户作假）；
	+ 5. 可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程，I/O 密集型进程；
+ **是否会导致饥饿?**
	+ 会
	+ 如果一直有短进程进来，则可能会导致原本的**长进程一直得不到时间片**；
+ 扩展： 可以将**因 I/O 而阻塞的进程**重新放回原队列，这样 I/O 型进程就可以保持高优先级；

**举例**
+ 概念：
	+ 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；
	+ 新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片； 
	+ 若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾；
	+ 只有**第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片**；
+ 进程图： 
	+ ![[Pasted image 20240318154511.png]]
+ 优先级队列：
	+ ![[Pasted image 20240318154626.png]]

### 3.5.5 交互式算法比较
**三类交互式算法比较**
+ 图示：
	+ ![[Pasted image 20240318000840.png]]
+ 总结：
	+ 比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统 （包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标；
	+ 而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如 UNIX 使用的就是多级反馈队列调度算法）；

## 3.6 多处理器调度 
### 3.6.1 基本概念
**两种处理方式**
+ 非对称多处理：
	+ 概念：让一个处理器 (主服务器)处理所有调度决定、IO 处理以及其他系统活动，其他的处理器只执行用户代码；
	+ 优点：简单，因为只有一个处理器访问系统数据结构，减少了数据共享的需要；
+ 对称多处理：
	+ 概念：
		+ 1. 每个处理器自我调度；
		+ 2. 所有进程处于一个共同的就绪队列中，或每个处理器都有它自己的私有就绪进程队列；
		+ 3. 每个处理器的调度程序都检查共同就绪队列，以便选择执行一个进程；
	+ 注意：需要对多个处理器试图访问和更新共同的数据结构进行仔细检查；

### 3.6.2 处理器亲和性 
**什么是处理器亲和性**
+ 产生原因：
	+ 当进行进程调度时，如果进程转移到其他处理器进行运行，第一个处理器缓存的内容就被设为无效，第二个处理器缓存应重新填充； 
	+ 缓存的无效或重新填充的代价高，所以大多数多处理器调度系统试图避免将进程从一个处理器移到另一个处理器，而是试图让一个进程运行在同一个处理器上；
+ 概念： 
	+ 一个进程对它运行的处理器具有亲和性，试图让一个进程运行在同一个处理器上；
+ 图示：
	+ ![[Pasted image 20240319152209.png]]

**软亲和性和硬亲和性**
+ 软亲和性：当一个操作系统试图保持进程运行在同一处理器上时 (但不保证它会这么做)，这种情况称为软亲和性；
+ 硬亲和性：允许某个进程运行在某个处理器子集上（通过提供系统调用以便支持硬亲和性）；

### 3.6.3 负载平衡 
**负载平衡与多处理器**
+ 概念：
	+ 1. 通过负载平衡充分利用多处理器的优点，防止出现一个或多个处理器会空闲、其他处理器会处于高负载状态；
	+ 2. 负载平衡设法将负载平均分配到 SMP 系统的所有处理器；
+ 两种方式：
	+ 推迁移：一个特定的任务周期性地检查每个处理器的负载，如果发现不平衡，那么通过将进程从超载处理器推到空闲或不太忙的处理器；
	+ 拉迁移：空闲处理器从一个忙的处理器上拉一个等待任务时，发生拉迁移；

**负载平衡和处理器亲和性**
+ 保持一个进程运行在同一处理器上的好处是进程可以利用它在该处理器缓存内的数据；
+ 无论是从一个处理器向另一处理器推或拉进程，都会失去这个好处；