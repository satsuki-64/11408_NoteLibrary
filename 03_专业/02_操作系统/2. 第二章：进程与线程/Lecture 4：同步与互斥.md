---
title: Lecture 4：同步与互斥
tags:
  - 操作系统
categories: 
date: 2024-03-22
---
---
## 4.1 进程同步与异步基础概念
### 4.1.1 进程同步与异步 
**同步**
+ 同步亦称为**直接制约关系**，它指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系；
+ 进程间的直接制约关系就是源于它们之间的**相互合作**；

**异步性**
+ 指各**并发执行的进程以各自独立的，不可预估的速度**向前推进。

### 4.1.2 进程互斥
**竞争条件**
+ 概念：多个进程并发访问和操作同一数据，并且执行结果与特定访问顺序有关，称为竞争条件；

**资源共享方式**
+ 1. 互斥共享方式
	+ 系统中的某些资源，虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程**访问该资源 (<u>临界资源</u>)；
+ 2. 同时共享方式
	+ 系统中的某些资源，允许**一个时间段内**由多个进程**同时**对它们进行访问；

**临界资源**
+ 概念：
	+ 指一个时间段内只允许一个进程使用的资源称为临界资源。
	+ 许多物理设备 (比如摄像头，打印机)都属于临界资源。
	+ 此外还有许多变量，数据，内存缓冲区等都属于临界资源。
+ 特点：
	+ 临界资源必须**互斥地**进行访问，亦称为间接制约关系；
	+ 当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待；
+ 注意：临界资源与共享资源区别 
	+ 临界资源：在同一个时间内**不能**被多个进程访问；
	+ 共享资源：在同一个时间内**能够**被多个进程访问；

**临界区以及四类分区**
+ 目的：
	+ 实现对对临界资源的互斥访问；
+ 概念：
	+ 每个进程有一段代码，称为临界区，
	+ 临界资源的互斥访问可以在逻辑上分为 4 个部分；
+ 作用：
	+ 负责检查是否可进入临界区：
	+ 1. 若可进入，则应设置正在访问临界资源的标志（进入区后上锁），以阻止其他进程同时进入临界区；
	+ 2. 若不可进入，则等待资源；
+ 四类分区
	+ 进入区
		+ 在进入临界区前，每个进程应请求许可；
		+ 负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志
	+ 临界区
		+ 每个进程中**访问临界资源的那段代码**。当一个进程在临界区内执行时，其他进程不允许在它们的临界区内执行；
	+ 退出区
		+ 负责解除正在访问临界资源的标志 (`解锁`)
	+ 剩余区
		+ 其他处理
	+ 图示：
		+ ![[Pasted image 20240328010322.png]]
+ 注意
	+ 临界区是进程中访问临界资源的代码段；
	+ 进入区和退出区是负责实现互斥的代码段；
	+ 临界区也可称为临界段；
+ 代码参考：
```c
//伪代码
do{
	entry section;    //进入区 `->` 上锁
	critical section; //临界区
	exit section;     //退出区 `->` 解锁
	remainder section;//剩余区
}while(true)
```

**临界区的四大访问原则**
1. **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
2. **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. **有限等待**：对请求访问的进程，应保证能在**有限时间内**进入临界区 (保证不会饥饿)；
4. **让权等待**：进不了临界区的进程，要释放处理机，**防止忙等**（无法使用，但一直在等待）；

## 4.2 进程互斥的软件实现方法
### 4.2.1 单标志法
**单标志法**
+ **算法思想**
	+ 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程；
	+ 也就是说：每个进程进入临界区的权限**只能被另一个进程赋予**；
+ **局限性**
	+ 违背了**空闲让进**原则
	+ 举例：有可能出现的情况：
		+ 进程 A 使用完之后，把权限给了进程 B 。但进程 B 当前不使用，而进程 A 此时如果过了一会还想要使用，因此 B 一直没开始使用，但一直有着 A 给的权限，导致当前想要使用的 A 无法从 B 上获得使用权，进而导致临界资源空闲；

**代码示例**
```c
/* 
1. turn的初值为0，即刚开始只允许0号进程进入临界区。
2. 若P1先上处理机运行，则会一直卡在5。直到 P1 的时间片用完，发生调度，切换 P0上处理机运行。
3. 代码1不会卡住 PO，PO 可以正常访问临界区，在 P0访问临界区期间即时切换回 P1，P1依然会卡。
*/
int turn = 0; //turn 表示当前允许进入临界区的进程号

//P0 进程
while (turn !=0);  //1
critial section;   //2
turn = 1;          //3
remainder section; //4

//P1 进程
while (turn != 1); //5 进入区
critical section;  //6 临界区
turn = 0;          //7 退出区
remainder section; //8 剩余区
```

### 4.2.2 双标志先检查
**双标志先检查法** 
+ **算法思想**
	+ 设置一个布尔型数组 `flag[]`，数组中各个元素用来标记**进程想进入临界区的意愿**；
	+ 每个进程在进入临界区之前先**检查当前有没有别的进程想进入临界区**，如果没有，则把自身对应的标志 `flag[i]` 设为 true，之后开始访问临界区；
+ **局限性**
	+ 问题：
		+ 当进程 AB 同时并发运行时 `->` `while(flag[1]);`  `->`  `while(flag[0]);` `->` `flag[0] = true;` `->` `flag[1] = true;`
		+ 这种情况下可能两个进程都进入运行；
	+ 问题的核心：检查&上锁两个操作并没有一起完成，而是分开成两个指令；
	+ 违背了**忙则等待**原则；

**代码示例**
```c
//flag[0] = true 表示0号进程P0想要进入临界区
bool flag[2];       //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;    //刚开始设置为两个进程都不想进入临界区

//P0 进程
while(flag[1]);  //1
flag[0] = true;  //2
critical = false;//3
flag[0] = false; //4
remainder section;

//P1 进程
while(flag[0]);  //5 如果此时P0想进入临界区，P1就一直循环等待
flag[1] = true;  //6 标记为P1进程想要进入临界区
critical section;//7 访问临界区
flag[1] = false; //8 访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

### 4.2.3 双标志后检查法
**双标志后检查法**
+ **算法思想**
	+ 双标志先检查的改版；
	+ 前一个算法的问题是先**检查**后**上锁**，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题；
	+ 因此，就有了先**上锁**，后**检查**的方法；
+ **局限性**
	+ 违背了**空闲让进**和**有限等待**原则；
	+ 会因各进程都无法访问临界资源而产生**饥饿**现象；
	+ 两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区；

**代码实现**
```c
bool flag[2];     //表示进入临界区意愿的数组
flag[0] = false; 
flag[1] = false;  //刚开始设置为两个进程都不想进入临界区

//P0 进程
flag[0] = true;  //1
while(flag[1]);  //2
critical = false;//3
flag[0] = false; //4
remainder section;

//P1 进程
flag[1] = true;  //5 如果此时P1想进入临界区，P1就一直循环等待
while(flag[0]);  //6 标记为P0进程想要进入临界区
critical section;//7 访问临界区
flag[1] = false; //8 访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

### 4.2.4 Peterson 算法
**Peterson 算法**
+ **算法思想**
	+ 如果双方都争着想进入临界区，那可以让进程尝试**互让**，主动**让对方先使用临界**区；
	+ 核心：
		+ 对 `turn` 变量的更改。表示当前的意愿；
	+ 进入区动作: 
		+ 1. 主动争取; 
		+ 2. 主动谦让;		
		+ 3. 检查对方是否也想使用，且最后一次是不是自己说了"客气话"；
	+ 谁最后说了“客气话”，谁就失去了行动的优先权；
+ **局限性**
	+ 解决了互斥问题，遵循了**空闲让进，忙则等待，有限等待**三个原则，但是依然**未遵循让权等待**的原则 `->` 当前访问不了临界资源的进程，依然需要在 while 循环中执行，占用 CPU 资源；
	+ 它是上面三种最好的，但是仍然能改进

**代码实现**
```c
bool flag[2];   //表示进入临界区意愿的数组，初始值都是false
int turn = 0;   //turn 表示优先让哪个进程进入临界区

//P0 进程
flag[0] = true;  //1
turn = 1;        //2
while (flag[1] && turn == 1); // 3
critical section;//4
flag[0] = false; //5
remainder section;

//P1 进程
flag[1] = true;  //6 表示自己想进入临界区
turn = 0;        //7 可以优先让对方进入临界区
while(flag[0] && turn == 0);  //8 对方想进，且最后一次是自己让它进，那自己就循环等待
critical section; //9
flag[1] = false;  //10 访问完临界区，表示自己已经不想访问临界区
remainder section;
```

## 4.3 进程互斥的硬件实现方法 
**基于软件的解决方案 (如 Peterson 解答)并不保证在现代计算机体系结构上正确工作。因此可以考虑硬件方法**

### 4.3.1 中断屏蔽方法
**中断屏蔽方法**
+ **算法思想**
	+ 利用开关中断机制实现 `->` 在修改共享变量时只要禁止中断出现，即可实现单处理器环境下的临界区问题； 
	+ 与原语的实现思想相同：即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换
+ **特点**
	+ 优点
		+ 简单，高效
		+ 往往为非抢占式内核所采用；
	+ 缺点
		+ 不适合用于**多处理机**；
		+ 只适用于操作系统内核进程，**不适用于用户进程**：因为开/关中断指令只能允许在内核态；

```c
关中断; //关中断后不允许当前进程被中断，也必然不会发生进程切换
临界区;
开中断; //直到当前进程访问完临界区，再执行开中断指令
```

### 4.3.2 TestAndSet
**TestAndSet 指令**
+ **算法思想**
	+ 简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 `TSL` 指令；
	+ TSL 指令是用硬件实现的，执行的过程**不允许被中断，只能一气呵成**；
+ **特点**
	+ 优点
		+ 1. 实现简单；
		+ 2. 无需像软件实现方法那样，不需要严格检查是否会有逻辑漏洞
		+ 3. 适用于多处理机环境
	+ 缺点
		+ 不满足**让权等待原则** `->` 在当前临界区被 TS 上锁的情况下，其他的访问进程需要在 `TestAndSet` 中一直被阻塞；
		+ 暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致**忙等** `->` CPU 占用；

**代码实现**
+ TSL 实现
	+ ![[Pasted image 20240328011759.png]]
```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true 表示已加锁，false表示未加锁
bool TestAndSet(bool *lock){
	bool old;
	old = *lock;   //old用来存放lock原来的值
	*lock = true;  //无论之前是否已加锁，都将lock设为true
	return old;    //返回lock原来的值
}
```
+ 使用
	+ ![[Pasted image 20240328011811.png]]
```c
//一下是使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));  //上锁并检查
//临界区代码段
lock = false;   //解锁
//剩余区代码段
```

### 4.3.3 Swap 指令
**Swap 指令**
+ **算法思想**
	+ 也叫 `Exchange` 指令，或简称 `XCHG` 指令
	+ Swap 指令是**用硬件实现的，执行的过程不允许被中断**，只能一气呵成。
+ **特点**
	+ 优点
		+ 1. 实现简单； 
		+ 2. 无需像软件实现方法那样严格检查是否会有逻辑漏洞；
		+ 3. 适用于**多处理机环境**；
	+ 缺点
		+ 1. 不满足**让权等待**原则；
		+ 2. 暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致**忙等**

**代码实现**
```c
//Swap 指令的作用是交换了两个变量的值
Swap(bool *a,bool *b){
	bool temp;
	temp = *a;
	*a = *b;
	*a = temp;
}
```

```c
//以下是用Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while(old == true)
	Swap(&lock,&old);
//临界区代码段
lock = false;
//剩余区代码段
```

### 4.3.4 进程互斥：锁
**互斥锁（自旋锁）**
+ 算法思想：
	+ 解决临界区最简单的工具就是互斥锁 (mutex lock)；
	+ 其内部实现机制通常也依赖于硬件指令；
+ 过程：
	+ 1. 一个进程在进入临界区时应获得锁；
	+ 2. 在退出临界区时释放锁；
	+ 3. 函数 `acquire()` 获得锁，而函数 `release()` 释放锁；
+ 优点：
	+ 等待期间不用切换进程上下文，多处理器系统中，**若上锁的时间短，则等待代价很低**；
+ 缺点：
	+ 互斥锁的主要缺点是：**忙等待**；
	+ 需忙等，进程时间片用完才下处理机，违反让权等待；
	+ 当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用 `acquire()`；
	+ 当多个进程共享同一 CPU 时，就浪费了 CPU 周期；
+ 使用环境：
	+ 互斥锁通常用于多处理器系统；
	+ 一个线程可以在一个处理器上等待，不影响其他线程的执行；一个核忙等，其他核照常工作，并快速释放临界区；

**代码实现**
```C 
acquire()
{
	//忙等待... 
	while(!available)
	{
		//...
		
	}
	available = false; // 获得锁
}

release()
{
	available = true; // 释放锁

}
```

## 4.4 信号量机制
**引入**
+ 上述的实现方式：
	+ `四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson 算法）` + `三种硬件实现方式（中断屏蔽方法、TS/TSL 指令、Swap/XCHG 指令）` 
+ 无法解决的问题：无法实现**让权等待**；

### 4.4.1 信号量机制
**信号量基础概念**
+ 信号量
	+ 1. 其实就是一个变量(可以是整数，也可以是更复杂的记录型变量)；
	+ 2. 可以用一个信号量来表示系统中某种资源的数量；
	+ 3. 使用 PV 操作对信号量进行操作；
+ 原语概念
	+ 是一种特殊的程序段，其执行只能一气呵成，不可被中断；
	+ 原语是由**关中断/开中断**指令实现的；
+ 信号量与忙等：
	+ 1. 操作 `wait()` 和 `signal()` 并没有完全取消忙等待；
	+ 2. 将忙等待（让权等待）从进入区移到临界区，并将忙等待的区域限制在操作 `wait()` 和 `signal()` 的临界区内，而这些区比较短；
	+ 结论：临界区几乎不被占用，忙等待很少发生，而且所需时间很短；

**PV 原语**
+ 性质：
	+ PV 操作是一种低级进程通信原语；
	+ PV 操作是**两个不可被中断**的原语；
+ 概念： 
	+ `wait(S)` 原语和 `signal(S)` 原语：可以把原语理解为我们自己写的函数，函数名分别为 `wait` 和 `signal`；
	+ `wait` `->` `proberen` `->` P 操作； 
	+ `signal` `->` `verhogen` `->` V 操作；
	+ 信号量 `S` ：函数调用时传入的一个参数；
	+ 常把 wait (S)，signal (S)两个操作分别写为 `P(S),V(S)`；
+ 原因： 
	+ 软件解决方案主要问题是由进入区的各种操作无法一气呵成；
	+ 因此如果能把进入区、退出区的操作都用**原语**实现，使这些操作能一气呵成就能避免问题；
+ P 操作：
	+ 概念：
		+ 1. 当一个进程执行操作 `wait()` 并且发现信号量值不为正时，它必须等待；
		+ 2. 该进程不是忙等待而是**阻塞**自己：阻塞操作将一个进程放到与信号量相关的**等待队列**中，并且将该进程状态切换成**等待状态**；
		+ 3. 控制转到 CPU 调度程序，以便选择执行另一个进程；
	+ 图示：
		+ ![[Pasted image 20240328173936.png]]
+ V 操作：
	+ ![[Pasted image 20240328173950.png]]

### 4.4.2 整型信号量
**整型信号量**
+ 原理
	+ 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。
+ 操作
	+ 对信号量的操作只有 3 种
	+ 初始化
	+ P 操作
		+ ![[Pasted image 20240328014536.png]]
	+ V 操作
		+ ![[Pasted image 20240328014543.png]]
+ 问题
	+ 不满足让权等待原则，会发生**忙等**；

**代码示例**
+ `int S`：表示信号量 `->` 表示系统中一种有限的资源的数量；
```c
//举例某计算机系统中有一台打印机
int S = 1; //初始化整型信号量s，表示当前系统中可用的打印机资源数

void wait (int S){  //wait 原语,相当于进入区
	while(S<=0);    //如果资源不够,就一直循环等待
	S = S-1;
}
void signal(int S){ //signal原语,相当于退出区
	S = S+1;        //使用完资源后，在退出区释放资源
}
```

```c
//P0 进程
wait(S);      //进程区，申请资源
使用打印机资源 //临界区，访问资源
signal(S);    //退出区，释放资源

//P1 进程
wait(S);
使用资源
signal(S);

//P2 进程
//同上略
```

### 4.4.3 记录型信号量
**记录型型号信号量**
+ **原理**
	+ 用记录型数据结构表示的信号量；
+ **解决问题**
	+ 解决整型信号量的忙等问题

**信号量定义**
+ 信号量组成：
	+ 1.  `S.value` 信号量值：其初值表示系统中某种资源的数目；
	+ 2.  `L` 进程链表：
		+ （1）当一个进程必须**等待信号量**时，就被添加到进程链表；
		+ （2）操作 `signal()` 从等待进程链表上取走一个进程，并加以唤醒；
+ 进程链表实现：
	+ 可以通过实现每个进程控制块 PCB 的一个链接字段，实现进程链表；
	+ 向链表中增加、删除进程，以便确保有限等待的一种方法是采用 FIFO 队列；
+ 注意：
	+ 信号量的正确使用不依赖于信号量的进程链表的特定排队策略；

**信号量操作实现**
+ 单处理器：
	+ 可以直接使用屏蔽中断的方式，来保证调用 PV 操作时可以原子的执行；
+ 多处理器环境：
	+ 分析：
		+ 对于多处理器环境，每个处理器的中断都应被禁止; 
		+ 否则在不同处理器上不同的运行进程，可能会以任意不同方式一起交织执行；
		+ 每个处理器中断的禁止会很困难，也会严重影响性能。
	+ 方法：
		+ SMP 系统应提供其他加锁技术如：`compare_and_swap()` 或自旋锁，以确保 `wait()` 与 `signal()` 原子执行；

**信号量代码定义**
```c
//记录型信号量的定义
typedef struct{
	int value;          //剩余资源数
	struct process *L;  //等待队列 `->` 指向等待它的进程，比如进程C因为value值为-1、无法访问时，此指针指向当前等待的进程； 
}semaphore;
```

**wait 操作**
+ wait 操作 `->` 也可以记为 `P()`； 
```c
//某种进程需要使用资源时,通过wait原语申请
void wait(semaphore （）S){
	S->value--;
	if(S->value < 0){
		add this process to S->list ;
		block(S.L);  //进入阻塞态，并把挂导信号量S的等待队列
	}
}
```

**signal 操作**
+ signal 操作 `->` 也可以记为 `V()`； 
+ 若加 1 后仍是 `S.value<=0`，表示：依然有进程在等待该类资源，因此应调用 `wakeup` 原语唤醒等待队列中的第 1 个进程
+ 被唤醒进程：从阻塞态 `->` 就绪态；
```c
//进程使用完资源后,通过signal 原语释放
void signal(semaphore *S){
	s->value++;
	if(S->value <= 0){
		remove a process P from S->list ;
		wakeup(S.L); //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
	}
}
```
+ 注意：若考试中出现 P(S)，V(S)的操作,除非特别说明，否则默认 S 为记录型信号量；

## 4.5 信号量机制实现
### 4.5.1 进程互斥
**信号量机制实现进程互斥**
1. 分析并发进程的关键活动，划定临界区所放代码；
2. 设置互斥信号量 `mutex`，初值为 1；
3. 在临界区之前执行**P (mutex)**
4. 在临界区之后执行**V (mutex)**

**注意**
+ 1. 对不同的临界资源需要设置不同的互斥信号量
+ 2. P，V 操作必须成对出现
	+ 缺少 P (mutex)就不能保证临界资源的互斥访问；
	+ 缺少 V (mutex)会导致资源永不被唤醒；

**补充**：优先级继承协议
+ 有正在访问资源的进程获得需要访问它的更高优先级进程的优先级，直到它们用完了有关资源为止。当它们用完时，它们的优先级恢复到原始值


**代码示例**
```c
//信号量机制实现互斥
semaphore mutex = 1;  //初始化信号量

P1(){
	...
	P(mutex);      //使用临界资源前需要加锁
	临界区代码段...
	V(mutex);      //使用临界资源后需要解锁
	...
}
P2(){
	...
	P(mutex);
	临界区代码段...
	V(mutex);
}
```

### 4.5.2 进程同步
**用信号量实现进程同步**
1. 分析什么地方需要实现**同步关系**，即必须保证**一前一后**执行的两个操作；
2. 设置同步信号量 S，初始为 0 ；
3. 在**前操作**之后执行 V (S)；
4. 在**后操作**之前执行 P (S)；

**代码定义与实现**
```c
//信号量机制实现同步
semaphore S=0;   //初始化同步信号量，初始值为0
```
+ 情况一：P 1 先执行 `V(S)`
	+ 若先执行到 V (S)操作，则 S++后 S=1；
	+ 之后当执行到 P (S)操作时，由于 S=1，表示有可用资源，会执行 S--，s 的值变回 0，P 2 进程不会执行 block 原语，而是继续往下执行代码 4； 
+ 情况二：P 2 先执行 P(S)
	+ 若先执行到 P (S)操作，由于 S=0，s--后 S=-1，表示此时没有可用资源，因此 P 操作中会执行 block 原语，主动请求阻塞；
	+ 之后当执行完代码 2，继而执行 V (S)操作，S++，使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P 2 进程。这样 P 2 就可以继续执行代码 4 了；
+ 结论：
	+ 通过设置 P、V 代码，`P1` 使用 V、`P2` 使用 P，保证了 `P1` 必须先使用、`P2` 必须后使用；
	+ **实现了同步操作**；
+ 图示：
	+ ![[Pasted image 20240322171141.png]]

**信号量机制实现前驱关系**
+ 情况描述：
	+ 按如下前驱图所示的顺序来执行 `->` 进程 P 1 中有句代码 S 1，P 2 中有句代码 S 2，P 3 中有句代码 S 3... P 6 中有句代码 S 6。这些代码要求
+ 执行方法：
	+ 1. 要为每一对前驱关系各设置一个同步信号量；
	+ 2. 在“前操作”**之后**对相应的同步信号量执行 V 操作； 
	+ 3. 在“后操作”**之前**对相应的同步信号量执行 P 操作；
	+ 图示：
		+ ![[1711098980407.png]]
+ 执行顺序：
	+ ![[1711099076143.png]]

## 4.6 生产者-消费者问题
### 4.6.1 问题描述
**基础概念**
+ 基本概念：
	+ 1. 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用 (注这里的“产品”理解为某种数据)；
	+ 2. 生产者、消费者共享一个初始为空、大小为 n 的缓冲区
+ 运作方式：
	+ 1. 缓冲区**没满**时，生产者才能**把产品放入缓冲区**，否则必须等待； 
	+ 2. 缓冲区**不空**时，消费者才能从中**取出产品**，否则必须等待； 
	+ 3. 缓冲区是临界资源，各进程必须**互斥地**访问（比如如果两个生产者进程同时进行生产，那有可能出现部分区域被覆盖）；
+ 图示： 
	+ ![[Pasted image 20240322142345.png]]

**分析步骤**
+ 1. 关系分析：找出题目中描述的各个进程，分析它们之间的**同步、互斥关系**；
	+ 需要两**种**信号量：
	+ 1. 互斥信号量；
		+ `semaphore mutex=1; //互斥信号量，实现对缓冲区的互斥访问`
	+ 2. 同步信号量；
		+ `semaphore full=0; //同步信号量，表示产品的数量，也即非空缓冲区的数量`
		+ `semaphore empty=n; //同步信号量，表示空闲缓冲区的数量，初始情况有n个空闲的缓冲区区域`
+ 2. 整理思路：根据各进程的操作流程，确定 P、V 操作的大致顺序；
	+ 有产品（`V操作`） `-(full)`->`` 消费者消费（`P操作`）；
	+ 生产者生产（`P操作`） `<-(empty)-` 缓冲区未满（`V操作`）；
+ 3. 设置信号量：根据题目条件确定信号量初值，互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少；

**注意事项**
+ 需要注意实现互斥和实现同步的两个 **P 操作的先后顺序**；
+ 实现互斥的 P 操作需要在实现同步的 P 操作之后，不然可能会**产生死锁**问题；
+ 不过 V 操作的顺序可以调换；

### 4.6.2 代码实现
**信号量初始化**
```c
semaphore mutex = 1;    //互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;    //同步信号量，表示空闲缓冲区的数量
semaphore full = 0;     //同步信号量，表示产品的数量，也即非空缓冲区的数量
```

**生产者 - 消费者实现**
```c
//生产者
producer(){
	while(1){
		//生产一个产品;
		P(empty);        //消耗一个空闲缓冲区

		//上锁
		P(mutex);        //互斥信号量P操作
		//把产品放入缓冲区;
		V(mutex);        //互斥信号量V操作
		//下锁

		V(full);         //增加一个产品
	}
}
```

```c
//消费者
consumer(){
	while(1){
		P(full);         //消耗一个产品(非空缓冲区)
		P(mutex);
		//从缓冲区取出一个产品;
		V(mutex);
		V(empty);        //增加一个空闲缓冲区
		//使用产品;
	}
}
```

**补充**：改变相邻 P、V 操作的顺序 `->` 互斥的 P 操作再同步的 P 操作之前 `->` 会发生死锁
+ 分析： 
	+ 若此时缓冲区内已经放满产品，则 empty=0，full=n。则生产者进程执行① 使 mutex 变为 0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于 mutex 为 0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞；
+ 结论：
	+ 1. 实现互斥的 P 操作一定要在实现同步的 P 操作之后，**P 操作顺序不可交换**； 
	+ 2. V 操作不会导致进程阻塞，因此两个 **V 操作顺序可以交换**； 

## 4.7 多生产者-多消费者问题
### 4.7.1 问题描述
**多生产者-多消费者 = 多种类的生产者消费者**

**问题描述**
+ 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程。
+ 问题抽象：
	+ 大小为 1，初始为空的缓冲区；
	+ 分别有两类生产者（生产者 1和生产者 2）以及对应的两个消费者；
+ 图示：
	+ ![[Pasted image 20240324154340.png]]

**问题分析**
+ 1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系；
	+ 互斥关系：对缓冲区 (盘子)的访问要互斥地进行
	+ 同步关系：(一前一后)
		+ 1. 父亲将苹果放入盘子后，女儿才能取苹果；
		+ 2. 母亲将橘子放入盘子后，儿子才能取橘子；
		+ 3. 只有盘子为空时，父亲或母亲才能放入水果（*盘子为空*这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）；
+ 2. 整理思路。根据各进程的操作流程确定 **P、V 操作的大致顺序**；
	+ 互斥关系：`mutex=1` ，对缓冲区 (盘子)的访问要互斥地进行；
	+ 同步关系： 
		+ 盘子：`plate = 1;`
		+ 父亲生产苹果：`apple = 0;`
		+ 母亲生产橘子：`orange = 0;`
+ 补充：关于互斥信号量
	+ 结论：在当前问题当中，即使不设置专门的互斥变量 mutex，也不会出现多个进程同时访问盘子的现象；
	+ 原因：本题中的缓冲区大小为 1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是 1。因此在任何时刻, 最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区；
+ 图示：
	+ ![[Pasted image 20240324154918.png]]

### 4.7.2 代码描述
**信号量初始化**
```c
//信号量
semaphore mutex = 1;      //实现互斥访问盘子(缓冲区)
semaphore apple = 0;      //盘子中有几个苹果
semaphore orange = 0;     //盘子中有几个橘子
semaphore plate = 1;      //盘子中还可以放多少个水果
```

**生产、消费**
```c
dad(){
	while(1){
		//准备一个苹果
		P(plate);
		P(mutex);        //加锁
		//把苹果放入盘子
		V(mutex);        //解锁
		V(apple);
	}
}
mom(){
	while(1){
		//准备一个橘子
		P(plate);
		P(mutex);
		//把橘子放入盘子
		V(mutex);
		V(orange);
	}
}
daughter(){
	while(1){
		//从盘子中取出苹果
		P(apple);
		P(mutex);
		//从盘中取出苹果
		V(mutex);
		V(palte);
		//吃掉苹果
	}
}
son(){
	while(1){
		P(oragne);
		P(mutex);
		//从盘中取出橘子
		V(mutex);
		V(plate);
		//吃掉橘子
	}
}
```

### 4.7.3 总结
+ **总结**
	+ 在生产者-消费者问题中，如果缓冲区大小为 1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能；
	+ 当然这不是绝对的，要具体问题具体分析
+ **建议**
	+ 在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥访问缓冲区。
	+ 但是需要注意的是，实现互斥的 P 操作一定要在实现同步的 P 操作之后，否则可能引起死锁

**PV 操作题目的解题思路**
+ 1. 关系分析
	+ 找出题目中描述的各个进程，分析它们之间的同步，互斥关系。	
+ 2. 整理思路
	+ 根据各进程的操作流程确定 P，V 操作的大致顺序。
+ 3. 设置信号量
	+ 设置需要的信号量，并根据题目条件确定信号量初值。
	+ 互斥信号量初值一般为 1，同步信号量的初值要看对应资源的初始值是多少

## 4.8 吸烟者问题
### 4.8.1 问题描述
**问题描述**
+ 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料: 烟草、纸和胶水。
+ 三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复 (让三个抽烟者轮流地抽烟)； 

**问题分析**
+ 1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系； 
	+ 互斥关系： 桌子可以抽象为容量为 1 的缓冲区，要互斥访问；
	+ 同步关系： 从事件角度分析
		+ 桌上有组合一 `->` 第一个抽烟者取走东西；
		+ 桌上有组合二 `->` 第二个抽烟者取走东西；
		+ 桌上有组合三 `->` 第三个抽烟者取走东西；
		+ 发出完成信号 `->` 供应者将下一个组合放到桌上；
+ 2. 整理思路。根据各进程的操作流程确定 P、V 操作的大致顺序
	+ PV 操作顺序:“前 V 后 P”
+ 3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值
	+ 桌上有组合一 `->` 第一个抽烟者取走东西 `->` `offer1=0`；
	+ 桌上有组合二 `->` 第二个抽烟者取走东西 `->` `offer2=0`；
	+ 桌上有组合三 `->` 第三个抽烟者取走东西 `->` `offer3=0`；
	+ 发出完成信号 `->` 供应者将下一个组合放到桌上 `->` `finish=0`；
+ 图示：
	+ ![[Pasted image 20240324160751.png]]

### 4.8.2 代码实现
**信号量初始化**
```c
semaphore offer1 = 0;   //桌上组合一的数量
sempahore offer2 = 0;   //桌上组合二的数量
sempahore offer3 = 0;   //桌上组合三的数量
semaphore finish = 0;   //抽烟是否完成
int i = 0;              //用于实现"三个抽烟者轮流抽烟"
```

**生产者、消费者**
+ 生产者
```c
provider(){
	while(1){
		if(i==0){
			将组合一放桌上;
			V(offer1);
		}else if(i==1){
			将组合二放桌上;
			V(offer2);
		}else if(i==2){
			将组合三放桌上;
			V(offer1=3);
		}
		
		//保证123轮流吸烟
		i = (i+1)%3;
		P(finsh);
	}
}
```
+ 消费者
```c
//吸烟者1 
smoker1 (){
	while(1){
		P(offer1);
		//从桌上拿走组合一;
		//烟卷;
		//抽掉;
		V(finish);
	}
}
//吸烟者2
smoker2 (){
	while(1){
		P(offer2);
		//从桌上拿走组合二;
		//烟卷;
		//抽掉;
		V(finish);
	}
}
//吸烟者3
smoker3 (){
	while(1){
		P(offer3)
		//从桌上拿走组合三;
		//烟卷;
		//抽掉;
		V(finish);
	}
}
```

### 4.8.3 总结
+ **问题类型**
	+ 可以生产多个产品的单生产者的问题；
+ **思想**
	+ 轮流让吸烟者吸烟必然需要轮流的在桌上放上组合一，二，三；
	+ 注意体会如何用一个整型变量i实现这个**轮流**过程的；
+ **注意**
	+ 若一个生产者要生产多种产品 (或者说会引发多种前驱事件)，那么各个 V 操作应该放在各自对应**事件**发生之后的位置。

## 4.9 读者 - 写者问题
### 4.9.1 问题描述
**问题描述**
+ 信息：
	+ 有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程 (读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误；
+ 要求：
	+ ①允许多个读者可以同时对文件执行读操作
	+ ②只允许一个写者往文件中写信息
	+ ③任一写者在完成写操作之前不允许其他读者或写者工作
	+ ④写者执行写操作前，应让已有的读者和写者全部退出。
+ 图示：
	+ ![[Pasted image 20240324162915.png]]

**问题分析**
+ 1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系； 
	+ 互斥关系： 
		+ 写进程一写进程、写进程一读进程；
		+ 进程与读进程不存在互斥问题；
		+ `mutex` `-(保证count的互斥访问)`->`` `count` `-(保证读进程运行时不进行写进程)`->`` `rw`：实现对共享文件的互斥访问；
+ 

### 4.9.2 代码实现
**信号量**
```c
semaphore rw = 1;    //用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
int count = 0;       //记录当前有几个读进程在访问文件
semaphore mutex = 1; //用于保证对count变量的互斥访问
semaphore w = 1;     //用于实现写优先
```

**1 生产者、n 消费者**
```c
writer(){
	while(1){
		P(w);
		P(rw);      //写之前加锁
		写文件...
		V(rw);      //写之后解锁
		V(w);
	}
}
```

```c
reader(){
	while(1){
		P(w);
		P(mutex);        //各进程互斥访问count
		if(count==0)
			P(rw);       //第一个读进程负责加锁
		count++;         //访问文件的读进程数+1
		V(mutex);
		V(w);
		读文件...
		P(mutex);        //各读进程互斥访问count
		count--;         //访问文件的读进程数-1
		if(count==0)
			V(rw);       //最后一个读进程负责解锁
		V(mutex);
	}
}
```

### 4.9.3 总结 
+ **解决问题**
	+ `P(rw)` 和 `V(rw)` 其实就是对共享文件的**加锁**和**解锁**。
	+ 既然各个读进程需要同时访问，而读进程与写进程必须互斥访问，那么我们可以让第一个访问文件的读进程**加锁**，让最后一个访问完文件的读进程**解锁**。
	+ 可以设置一个整数变量 count 来记录当前有几个读进程在访问文件。
+ **结论**
	+ 在这种算法中，连续进入的多个读者可以同时读文件; 
	+ 写者和其他进程不能同时访问文件; 
	+ 写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。 
	+ 有的书上把这种算法称为“读写公平法”
+ **思考**
	+ 若两个读进程并发执行，则两个读进程有可能先后执行 P (rw)，从而使第二个读进程阻塞的情况。
+ **解决**
	+ 出现上述问题的原因
		+ 在于对 count 变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对 count 的访问是互斥的。

## 4.10 哲学家进餐问题
### 4.10.1 问题描述
**问题描述**
+ 信息：
	+ 一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子 (一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下子继续思考；
+ 图示：
	+ ![[Pasted image 20240324170403.png]]

**问题分析**
+ 1. 关系分析。
	+ 系统中有 5 个哲学家进程，5 位哲学家与左右邻居对其中间筷子的访问是**互斥关系**；
+ 2. 整理思路。
	+ 这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时**持有两个临界资源**才能开始吃饭；
	+ 如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓；
+ 3. 信号量设置。
	+ 定义互斥信号量数组 `chopstick[5]={1,1,1,1,1}` 用于实现对 5 个筷子的互斥访问；
	+ 并对哲学家按 0~4 编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。

**临界资源问题**
+ 问题：可能会出现五个哲学家全部同时的阻塞，都不能吃饭；
+ 解决方案：
	+ 1. 可以对哲学家进程施加一些限制条件，比如**最多允许四个哲学家同时进餐**；
		+ 这样可以保证至少有一个哲学家是可以拿到左右两只筷子的；
	+ 2. 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反；
		+ 用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。
		+ 这就**避免了占有一支后再等待另一只**的情况
	+ 3. 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子；
		+ 这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子；
		+ 各哲学家拿筷子这件事必须互斥的执行；
		+ 这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子；
		+ 这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了:
		+ ![[Pasted image 20240324170647.png]]

**总结**
+ 如果在考试中遇到了**一个进程需要同时持有多个临界资源**的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁；

### 4.10.2 代码实现
```c
//限制仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1;     //互斥地取筷子
Pi(){                    //i号哲学家的进程
	while(1){
		P(mutex);
		P(chopstick[i]);       //那左
		P(chopstick[(i+1)%5]); //拿右
		V(mutex);
		吃饭...
		V(chopstick[i]);       //放左
		V(chopstick[(i+1)%5]); //放右
		思考...
	}
}
```

## 4.11 管程
### 4.11.1 基础概念
**什么么需要管程**
+ 信号量机制存在的问题：编写程序困难、易出错；
+ 1973 年，Brinch Hansen 首次在程序设计语言 Pascal 中引入了“管程”成分-，作为一种高级的同步机制；

**什么是管程**
+ 注意：管程不等于管道
+ 基本概念： 
	+ 管程提供一组由程序员定义的、在管程内互斥的操作；管程类型也包括一组变量，用于定义这一类型的实例状态，也包括操作这些变量的函数实现；
	+ 管程结构确保每次只有一个进程在管程内处于活动状态。因此，程序员不需要明确编写同步约束；
	+ 管程是一种**特殊的软件模块**，由这些部分组成：
		+ 1. 局部与管程的共享数据结构说明；
		+ 2. 对该数据结构进行操作的一组过程(**函数**)；
		+ 3. 对局部于管程的共享数据设置初始值的语句；
		+ 4. 管程有一个名字；
+ 管程的基本特征
	+ 1. 局部于管程的数据只能被局部于管程的过程所访问：只有管程内定义的函数才能访问管程内的局部声明的变量和形式参数；
	+ 2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
	+ 3. 每次仅允许一个进程在管程内执行某个内部过程；

### 4.11.2 用管道解决生产者-消费者问题 
```java
monitor ProduceConsumer
condition full,empty;      //条件变量用来实现同步(排队)
int count = 0;  //缓冲区中的产品数
void insert(Item item){    //把产品item放入缓冲区
	if(count == N)
		wait(full);
	count++;
	insert_item(item);
	if(count == 1)
		signal(empty);
}
Item remove(){  //从缓冲区中取出一个产品
	if(count==0)
		wait(empty);
	count--;
	if(count==N-1)
		signal(full);
	return remove_item();
}
end monitor;
```

```java
//生产者进程
producer(){
	while(1){
		item = 生产一个产品;
		ProdecerConsumer.insert(item);
	}
}

//消费者进程
consumer(){
	while(1){
		item = ProdecerConsumer.remove();
		消费产品item;
	}
}
```

### 4.11.3 总结
**引入管程的目的无非是要更方便地实现进程互斥和同步**
1. 需要在管程中定义共享数据
2. 需要在管程中定义用于访问这些共享数据的**入口**(函数)
3. 只有通过这些特定的**入口**才能访问共享数据
4. 管程中有很多**入口**，但是每次只能开放其中一个**入口**，并且只能让一个进程或线程进入 (互斥特性由编译器负责实现，程序员不用关心)
5. 可在管程中设置条件变量及其等待/唤醒操作以解决同步问题。
	+ 可以让一个进程或线程在条件变量上等待 (此时，该进程应先释放管程的使用权，也就是让出**入口**)
	+ 可以通过唤醒操作将等待在条件变量上的进程或线程唤醒

**注意**
+ 程序员可以用某种特殊的语法定义一个管程
+ 之后其他程序员就可以使用这个管程提供的特定**入口**很方便地使用实现进程同步/互斥 (封装思想)