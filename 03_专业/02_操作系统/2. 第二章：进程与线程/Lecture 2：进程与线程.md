---
title: Lecture 2：进程与线程
tags:
  - 操作系统
categories: 
date: 2024-03-15
---
## 2.1 进程的基本概念
### 2.1.1 进程的定义
**程序**
+ 就是一个指令序列，程序本身不是进程。程序只是被动 (passive)实体，如存储在磁盘上包含一系列指令的文件；
+ 早期的计算机 （只支持单道程序）

**进程的定义**
+ 比较传统典型的定义有：
1. 进程是程序的一次执行过程；
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动；
3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。
4. 进程是活动 (active)实体，具有一个程序计数器用于表示下个执行命令和一组相关资源。当一个可执行文件被加载到内存时，这个程序就成为进程；
+ 进程实体下的进程定义：
	+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 

**进程与程序的关系**
+ 一个进程可以顺序的执行多个程序；
+ 一个程序可以对应多个进程：即多个进程可以执行同一个程序；

### 2.1.2 进程的组成
**进程的构成**
+ 概念：
	+ 程序段，数据段，PCB 三部分组成了**进程实体（进程映像）**；
	+ 一般情况下，我们把**进程实体就简称为进程**；
	+ PCB 是**进程存在的唯一标识**，系统是根据 PCB 来感知进程的存在，其常驻内存；
+ PCB：
	+ 包含进程描述信息、进程控制和管理信息、资源分配信息、处理机相关信息；
+ 程序段（文本段）：
	+ 包含程序指令；
+ 数据段：
	+ 包含运行过程中产生的各种数据；
+ 堆栈：
	+ 包括临时数据，如函数参数、返回地址和局部变量；
+ **注意：**
	+ 进程实体和进程并不一样：进程实体是静态的，进程则是动态的；
	+ 除非题目专门考察二者区别，否则可以认为进程实体就是进程；

#### 2.1.2.1 进程控制块
**PCB** 
+ 进程状态：可以包括新的、就绪、运行、等待、停止等；
+ 程序计数器 (programcounter)：计数器表示进程将要执行的下个指令的地址
+ **进程描述信息**：
	+ 进程标识符 PID
	+ 用户标识符 UID
+ **进程控制和管理信息**：
	+ 进程当前状态
	+ 进程优先级
+ **资源分配清单**：
	+ 程序段指针
	+ 数据段指针
	+ 键盘
	+ 鼠标
+ **处理机相关信息**：
	+ 各种寄存器值

**PCB 示例图示**
+ 图示
	+ ![[Pasted image 20240319000407.png]]

#### 2.1.2.2 进程切换 
**进程间的 CPU 切换**
+ 图示： 
	+ ![[Pasted image 20240319000603.png]]

### 2.1.3 进程的组织方式
**进程的组织方式**
+ 链接方式：
	+ 按照进程状态将 PCB 分为多个队列
	+ 操作系统持有指向各个队列的指针
+ 索引方式：
	+ 根据进程状态的不同，建立几张索引表
		+ 操作系统持有指向各个索引表的指针

**链接方式**
+ 不同状态下的进程，使用不同的队列来链接不同状态的进程；
+ 图示：
	+ ![[Pasted image 20240315193240.png]]

**索引方式**
+ 使用索引表，用索引表的表项来获得不同状态的进程；
+ 图示：
	+ ![[Pasted image 20240315193300.png]]
### 2.1.4 进程的特征
**进程的特征**
+ 动态性：
	+ 进程是程序的一次执行过程，是动态地产生，变化和消亡的；
	+ 进程最基本的特征
+ 并发性：
	+ 内存中有多个进程实体，各进程可并发执行；
	+ 推导特征：**不可再现性** 
		+ 并发进程之间相互竞争和制约，导致每次运行可能得到不同的结果；
+ 独立性：
	+ 进程是能独立运行，独立获得资源，独立接受调度的基本单位
	+ **进程是资源分配，接受调度的基本单位**
+ 异步性：
	+ 各进程按各自独立的，不可预知的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题
+ 结构性：
	+ 每个进程都会配置一个 PCB。
	+ 结构上看，进程由程序段，数据段，PCB 组成

**补充特定**：进程的封闭性
+ 进程执行的结果只取决于其自身，不受外界影响；
+ 封闭性指的是：进程在执行时的**执行速度不会影响它的执行结果**；
## 2.2 进程的状态与转换
### 2.2.1 进程的状态
**进程的三种基本状态**
+ 就绪态（Ready）： 
	+ 已经具备运行条件，但由于没有空闲 CPU，而暂时不能运行；
+ 运行态（Running）： 
	+ 占有 CPU，并在 CPU 上运行；
	+ 多核 CPU 的情况下，可以有多个进程处于运行态；
	+ 无论是单 CPU 还是多核 CPU 下，都可能**同时多个进程都不处于运行态**（发生死锁时，可能出现所有进程都阻塞）；
+ 阻塞态（Waiting/Blocked，又称： 等待态）：
	+ 因等待某一事件而暂时不能运行；
 
**进程的另外两种状态**
+ 创建态（New，又称：新建态）
	+ 进程正在被创建，操作系统为进程分配资源，初始化 PCB；
+ 终止态（Terminated，又称：结束态）
	+ 进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销 PCB
+ 注意： 单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境可以两个）


###  2.2.2 进程状态的转换
**进程状态间的转换**（重点）
+ 重点：
	+ 就绪态—>运行态：
		+ 进程被调度；
	+ 运行态—>就绪态：
		+ 1. 时间片到；
		+ 2. CPU 被其他高优先级的进程抢占；
	+ 运行态—>阻塞态：
		+ 等待系统资源分配，或等待某事件发生 （主动行为）；
		+ 是一种**进程本身的主动行为**；
	+ 阻塞态—>就绪态：
		+ 1. 资源分配到位；
		+ 2. 等待的事件发生 （被动行为）；
		+ 3. 所请求的 IO 操作完成后； 
		+ 是一种进程受 OS 控制的**被动行为**；
+ 其他：
	+ 创建态—>就绪态：系统完成创建进程相关工作；
	+ 运行态—>终止态：进程运行结束，或运行过程中遇到不可修复的错误；
+ 图示：
	+ ![[Pasted image 20240315193505.png]]

## 2.3 进程控制  
### 2.3.1 进程控制的定义
**什么是进程控制**
+ **定义**
	+ 主要功能是对系统中的所有进程实施有效管理，它具有创新进程，撤销已有进程，实现，进程状态转换等功能。
+ **简化理解**
	+ 进程控制就是要实现进程状态转换
+ 图示：
	+ ![[Pasted image 20240315193620.png]]

### 2.3.2 进程控制实现：原语
**用原语实现进程控制**
+ 为什么要使用原语 
	+ 原语的特点是执行期间不允许中断，只能一气呵成，这种不可被中断的操作即原子操作；
	+ 如果不使用原语，可能会因为中断导致进程状态切换的时间不一致性；
+ 原语的原子性
	+ 原语的实现：
		+ 1. 原语采用关中断指令和开中断指令实现； 
		+ 2. 关中断和开中断是**只允许在核心态下执行的特权指令**；
		+ 2. 原语的指令被放在了关中断和开中断指令之间，因此在原语指令过程当中，程序不会接收到外部中断的影响；
	+ 什么是关中断：CPU 执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查；
	+ 什么是开中断：CPU 执行了开中断指令之后，继续例行检查中断信号；

**原语 3 个基本功能**
1. 跟新 PCB 中的信息 （如修改进程状态标识，将允许环境保存到 PCB，从 PCB 恢复允许环境）
	1. 所有的进程控制原语一定都会修改进程状态标识
	2. 剥夺当前运行进程的 CPU 使用权必然需要保存其运行环境
	3. 某些进程开始运行前必然要恢复运行环境
2. 将 PCB 插入合适的队列
3. 分配/回收资源

### 2.3.3 进程的创建
**进程的创建**
+ **创建原语：**
	+ 申请空白 PCB
	+ 为新进程分配所需资源
	+ 初始化 PCB
	+ 将 PCB 插入就绪队列
+ **引起进程创建的事件：**
	+ 用户登录：
		+ [[1 + 3 操作系统的发展与分类 1#^mk-202302261303|分时系统]]中，用户登录成功，系统会为其建立一个新的进程
	+ 作业调度：
		+ [[1 + 3 操作系统的发展与分类 1#^mk-202302272048|多批处理系统]]中，有新的作业放入内存时，会为其建立一个新的进程
	+ 提供服务：
		+ 用户向操作系统提出某些请求时，会新建一个进程处理该请求
	+ 应用请求：
		+ 用户进程主动请求创建一个子进程
+ 无—>创建态—>就绪态

**进程树**
+ 概念：
	+ 1. 创建进程称为父进程，而新的进程称为子进程；
	+ 2. 每个新进程可以再创建其他进程，从而形成进程树；
+ 根进程：
	+ Linux 中的 init 为根进程，其 pid 为 1；

**资源子集与子进程**
+ 概念： 
	+ 当一个进程创建子进程时，该子进程会需要一定的资源，这些资源可以从 OS 分配，也可以从父进程来分配资源子集；
+ 新进程的地址空间有两种可能：
	+ 子进程是父进程的复制品；
	+ 子进程加载另一个新程序；

**父进程使用 fork 创建子进程**
+ 代码：
```C
#include <sys/types.h>
#include<stdio.h>
#include<unistd.h>

int main()
{
	pid_t pid;
	/* fork a child process */
	pid = fork();

	/*error occurred */
	if(pid<0)
	{
		fprintf(stderr,"Fork Failed");
		return 1;
	}
	else if(pid==0)
	{
		/* child process */
		execlp("/bin/ls","ls",NULL);
	}
	else/*parent process */
	{
		wait(NULL);
		printf("child Complete");
	}
}

```
+ 图示：   
	+ ![[Pasted image 20240319002001.png]]

### 2.3.4 进程中止
**进程的终止**
+ **撤销原语**：
	+ 从 PCB 集合中找到终止进程的 PCB
	+ 若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程
	+ 终止其所有子进程
	+ 将该进程拥有的所有资源归还给父进程或操作系统
	+ 删除 [[2 + 1 + 1 进程的概念#^mk-202302270904|PCB]]
+ **引起进程终止的事件：**
	+ 正常结束：当进程完成执行最后语句并且通过系统调用 `exit()` 请求操作系统删除自身； 
	+ 异常结束
	+ 外界干预：
		+ 1. 进程通过适当系统调用 (如 Windows 的 `Terminate-Process ()`)，可以终止另一进程；
		+ 2. 通常只有终止进程的父进程才能执行这一系统调用；
+ 就绪态/阻塞态/运行态—>终止态—>无

**级联终止**
+ 概念：
	+ 有些系统不允许子进程在父进程已终止的情况下存在；
	+ 对于这类系统，如果一个进程终止 (正常或不正常)，那么它的所有子进程也应终止；
+ 级联终止 (cascadetermination) 通常由操作系统来启动； 

### 2.3.5 进程的阻塞、唤醒和切换
**进程的阻塞和唤醒**
+ **进程的阻塞：**
	+ 阻塞原语：
		+ 找到要阻塞的进程对应的 PCB
		+ 保护进程运行现场，将 PCB 状态信息设置为**阻塞态**，暂时停止进程运行
		+ 将 PCB 插入相应事件的等待队列
	+ 引起进程阻塞的事件：
		+ 需要等待系统分配某种资源
		+ 需要等待相互合作的其他进程完成工作
	+ 运行态—>阻塞态
+ **进程的唤醒：**
	+ 唤醒原语：
		+ 在事件等待队列中找到 PCB
		+ 将 PCB 从等待队列移除，设置进程为就绪态
		+ 将 PCB 插入就绪队列，等待被调度
	+ 引起进程唤醒的事件：
		+ 等待的事件发生
	+ 阻塞态—>就绪态

**进程的切换**
+ 切换原语的原理：
	+ 1. 将运行环境信息 (上下文环境)存入 PCB
	+ 2. PCB 移入相应队列
	+ 3. 选择另一个进程执行，并更新其 PCB
	+ 4. 根据 PCB ，恢复新进程所需的运行环境；
	+ 综述：讲当前进程的执行上下文保存在当前程序的 PCB 当中，在 PCB 保存当前进程作为状态机时的状态（状态=指令的执行+寄存器）；
+ 引起进程切换的事件：
	+ 当前进程时间片到
	+ 更高优先级的进程到达
	+ 当进程主动阻塞
	+ 当进程终止
+ 运行态—>阻塞态/就绪态
+ 就绪态—>运行态

## 2.4 进程通信
**进程通信**：进程间通信 （Inter-Process Communication，IPC）是指两个进程之间产生数据交互。
### 2.4.1 进程通信的概念
**什么是进程通信**
+ 概念：指进程之间的信息交换。
+ 原因
	+ 进程是分配系统资源的单位 （包括内存地址空间），因此各进程拥有的内存地址空间相互独立。
	+ **注意：** 为了保证安全，一个进程不能直接访问另一个进程的地址空间；

**三种进程间通信方式**
+ 1. 共享存储；
+ 2. 消息传递；
+ 3. 管道通信；

### 2.4.2 共享存储
**两种方式**
+ 基于数据结构（低级）；
+ 基于存储区的共享 （高级）；

**基于存储区的共享**
+ 概念： 
	+ 基于数据结构的共享；共享空间可以被多个进程进行使用； 
	+ 比如 Linux 中的 `shmap_open()` 接口可以用于访问共享存储区；
+ 特点：
	+ 1. 共享存储中的访问需要时互斥的（比如用 PV 操作、上锁）；
	+ 2. 共享存储区中的存放位置由进程控制，而不是操作系统；
	+ 3. 共享内存速度通常快于消息传递；
		+ 这是因为消息传递的实现经常采用系统调用，因此需要消耗更多时间以便内核介入；
		+ 共享内存系统仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核；
		+ 补充：*对具有多个处理核系统的最新研究表明：在这类系统上，消息传递的性能要优于共享内存。共享内存会有高速缓存一致性问题，这是由共享数据在多个高速缓存之间迁移而引起的。随着系统的处理核的数量的日益增加，可能导致消息传递作为 IPC 的首选机制；*
+ 图示：
	+ ![[Pasted image 20240315193915.png]]

**基于数据结构的共享**
+ 概念：   
	+ 比如共享空间里只能放一个长度为 10 的数组；
+ 特点：
	+ 这种共享方式速度慢、限制多，是一种**低级通信**方式；
+ 图示：
	+ ![[Pasted image 20240315220513.png]]

### 2.4.3 消息传递
**消息**
+ 概念： 
	+ 进程间的数据交换以格式化的消息（Message）为单位；
	+ 进程通过操作系统提供的**发送消息/接受消息**两个原语进行数据交换；
+ 特点：
	+ 消息传递对于交换较少数量的数据很有用，因为无需避免冲突；
	+ 对于分布式系统，消息传递比共享内存更易实现；
+ 图示：什么是消息
	+ ![[Pasted image 20240315194119.png]]

**发送原语**
+ 发送：`send(Q,msg);`
+ 接受：`receive(P,&msg);`

**消息的等待队列**
+ 零容量 (zero capacity)：队列的最大长度为 0
	+ 因此，链路中不能有任何消息处于等待； 
	+ 对于这种情况，发送者应阻塞，直到接收者接收到消息；
+ 有限容量 (boundedcapacity)：队列长度为有限的 n 
	+ 因此，最多只能有 n 个消息驻留其中； 
	+ 如果在发送新消息时队列未满，那么该消息可以放在队列中 (或者复制消息或者保存消息的指针)，且发送者可以继续执行而不必等待；
	+ 链路容量是有限的，如果链路已满，那么发送者应阻塞，直到队列空间有可用的为止；
+ 无限容量 (unbounded capacity)：队列长度可以无限 
	+ 因此，不管多少消息都可在其中等待； 
	+ 发送者从不阻塞；

**两种消息传递的方式**
+ 直接通信方式：
	+ 概念：发送进程需要指明接受进程的 ID，消息直接挂到接收进程的消息缓冲队列上；
	+ 原语： 
		+ `send (P，message)`：向进程 P 发送 message； 
		+ `receive (Q，message)`：从进程 Q 接收 message； 
	+ 方式：
		+ 1. 发送方进程 P 使用 `send` 原语讲消息发送到内核当中、进程 Q 的消息队列上；
		+ 2. 从消息队列中根据进程 Q 的 PCB，匹配到进程 Q 的地址，调用接受原语 `receive`；
		+ 3. 进程 Q 接收到内核的消息；
	+ 缺点：硬编码
		+ 更改进程的标识符可能需要分析所有其他进程定义；
		+ 所有旧的标识符的引用都应找到，以便修改成为新标识符；
+ 间接通信方式：
	+ 概念：消息要先发送到中间实体 （信箱）中，因此也称**信箱通信方式**；
	+ 原语： 
		+ `send (A，message)`：向邮箱 A 发送 message； 
		+ `receive (A，message)`：从邮箱 A 接收 message；
	+ 方式：
		+ 1. 进程 P 申请一个 A 邮箱和 B 邮箱；
		+ 2. 进程 P 在自己的地址空间中实例化信箱内容；
		+ 3. 使用发送原语，指定 `send` 要发送的信箱 A；
		+ 4. 进程 Q 使用接收原语，接受信箱 A 的信息；
	+ 图示：
		+ ![[Pasted image 20240315194155.png]]

### 2.4.4 管理通信
**管道**
+ 概念：
	+ 用于连接读写进程的一个共享文件，又名 `pipe` 文件；其实就是在内存区中开辟一个大小固定的缓冲区；
	+ 管道是早期 UNIX 系统最早使用的一种 IPC 机制，
+ 方式：
	+ 新建管道：一片空间中大小固定的内存区域；
	+ UNIX 下的普通管道创建：`pipe(int fd[])`
	+ 通过文件描述符 `int fd[]` 来访问:
		+ `fd[0]` 为管道的读出端；
		+ `fa[1]` 为管道的写入端； 
	+ UNIX 将管道作为一种特殊类型的文件，因此访问管道可以采用普通的系统调用 read()和 write()； 
+ 图示：
	+ ![[Pasted image 20240315194011.png]]
+ 管道的访问图示：
	+ ![[Pasted image 20240319004826.png]]

**管道的特点**
1. 两个只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道；
2. 各进程要**互斥**地访问管道；
3. 数据以字符流的形式写入管道，当管道写满时，写进程的 `write()` 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的 `read()` 系统调用将被阻塞；
4. 如果没写满，就不允许读。如果没读，就允许写；
5. 数据一旦被读出。就从管道中被抛弃，这意味着读进程最多只能有一个，否则可能会有读错数据的情况;
	1. 情况一：一个管道运行多个写进程，一个读进程；
	2. 情况二：一个管道允许多个写进程，多个读进程，但多个读进程需要轮流从管道中读取数据；

## 2.5 线程
### 2.5.1 什么是线程
**为什么需要线程**
+ 引入线程，来增加进程的并发度。引入后，线程成为程序执行流的最小单位；
+ 引入后，进程只作为除 CPU 之外的**系统资源的分配单元**；

**什么是线程**
+ 是一个基本的 CPU 执行单元，也是**程序执行流的最小单位**；
+ 其他定义：CPU 使用的基本单元，它构成多线程计算机系统的基础；

**线程的特点**
+ 1. **资源分配，调度**
	+ 传统进程机制中，进程是资源分配、调度的基本单位
	+ 引入线程后，<u>进程是资源分配的基本单位，线程是调度的基本单位</u>；
+ 2. **并发性**
	+ 传统进程机制中，只能进程间并发
	+ 引入线程后，各线程间也能并发，提升了并发度
+ 3. **系统开销**
	+ 传统的进程间并发，需要切换进程的运行环境，系统开销很大
	+ 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境。系统开销小
	+ 引入线程后，并发所带来系统开销减小
+ 4. **阻塞性**
	+ 如果一个交互程序采用多线程，那么即使部分阻塞或者执行冗长操作，它仍可以继续执行，从而增加对用户的响应程度；
	+ 这对于用户界面设计尤其有用；
+ 5. 便于进程通信

**Windows 线程的数据结构**
+ 基本概念：
	+ ETHREAD 和 KTHREAD 完全位于内核空间：这意味着只有内核可以访问它们；
	+ TEB 是个用户空间数据结构，以供线程在用户模式下运行时访问；
	+ TEB 除了包括许多其他域外，还包括线程标识符、用户模式堆栈以及用于线程本地存储的数组等；
+ 图示： 
	+ ![[Pasted image 20240319010152.png]]

### 2.5.2 线程的组成
**多线程与进程**
+ 共享部分：
	+ 它与同一进程的其他线程共**享代码段、数据段和其他操作系统资源**；
+ 单独部分：
	+ 包括**线程 ID、程序计数器、寄存器组和堆栈**；
+ 图示： 进程中的多个线程
	+ ![[Pasted image 20240319005102.png]]

**线程的属性**
+ 线程是处理机调度的单位；
+ 多 CPU 计算机中，各个线程可占用不同的 CPU；
+ 每个线程都有一个线程 ID，线程控制块 （TCB）；
+ 线程也有就绪，阻塞，运行三种基本状态；
+ 线程几乎不拥有系统资源；
+ 同一进程的不同线程间共享进程的资源；
+ 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预；
+ 同一进程中的线程切换，不会引起进程切换
+ **不同进程中的线程切换，会引起进程切换**；
+ 切换同进程内的线程，系统开销很小
+ 切换进程，系统开销较大

### 2.5.3 线程实现方式
**用户级线程** 
+ 概念： 
	+ 由应用程序通过线程库实现，所有线程管理工作都由应用程序负责，包括线程切换；
	+ 操作系统对于线程一无所知，只是面向进程进行调度与分配；
	+ **内核的事件不会影响到用户态线程的切换**，比如异常处理、IO 请求、系统调用等；
+ 说明：
	+ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
	+ 在用户看来，是有多个线程，线程的切换工作由进程进行；
	+ 但是在操作系统内核看来，并意识不到线程的存在；
+ 图示：
	+ ![[Pasted image 20240315194617.png]]
+ 优缺点：
	+ 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；
	+ 缺点：如果其中的一个线程被阻塞，整个进程都会被阻塞  ->  进程的并发度不高；

**内核级线程** 
+ 概念：   
	+ 其线程的管理工作由操作系统内核完成，线程的切换都需要操作系统接入；
	+ 内核级线程的切换需要在核心态下才能完成；
+ 图示：
	+ ![[Pasted image 20240315194649.png]]
+ 优缺点：
	+ 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。**多线程可在多核处理机上并行执行**；
	+ 缺点：一个用户进程会占用多个内核级线程，线程的切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大；

### 2.5.4 线程的状态与转换
**状态切换**
+ 一共三种状态进行相互切换；
+ 图示： 
	+ ![[Pasted image 20240315223651.png]]

**线程的组织与控制**
+ TCB：线程控制块
+ 图示：    
	+ ![[Pasted image 20240315223753.png]]
+ 线程表：
	+ 将多个 PCB 进行管理；

### 2.5.5 线程池 
**基本概念**
+ 在进程开始时创建一定数量的线程，并加到池中以等待工作； 
+ 当服务器收到请求时，它会唤醒池内的一个线程 (如果有可用线程)，并将需要服务的请求传递给它； 
+ 一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么服务器会等待，直到有空线程为止；

**优点**
+ 速度快：用现有线程服务请求比等待创建一个线程更快；
+ 限制性：线程池限制了任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要；
+ 不同策略：将要执行任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。例如，任务可以被安排在某一个时间延迟后执行，或定期执行；
## 2.6 多线程模型
**多对一模型**
+ 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
	+ 补充：Green threads 的多对一线程库为 Solaris 所采用；
+ **特点：**
	+ 优点：
		+ 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；
	+ 缺点：
		+ 1. 当**一个用户级线程被阻塞后，整个进程都会被阻塞**，**并发度不高**;
		+ 2. 由于内核只能一次调度一个线程，所以**并未增加并发性**，多个线程不可在多核处理机上并行运行；
+ 图示：
	+ ![[Pasted image 20240315194828.png]]

**一对一模型**
+ 一个用户及线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程；
+ **特点：**
	+ 优点：
		+ 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强
		+ 一对一模型提供了更大的并发性；
	+ 缺点：
		+ 一个进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大;
+ 图示：
	+ ![[Pasted image 20240315194836.png]]

**多对多模型**
+ 概念： 
	+ n 用户及线程映射到 m 个内核线程（$n>=m$）
	+ 每个用户进程对应 m 个内核级线程
+ **特点：**
	+ 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点；
+ 图示：多核 CPU 环境下，图中进程最多能被分配两个核；
	+ ![[Pasted image 20240315194858.png]]

