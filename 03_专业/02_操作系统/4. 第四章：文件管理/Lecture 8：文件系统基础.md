## 8.1 什么是文件管理
**文件的属性**
+ 文件名
	+ 由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录不允许有重名文件；
+ 标识符
	+ 一个系统内的各**文件标识符唯一**，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称；
+ 类型
	+ 指明文件的类型
+ 位置
	+ 文件存放的路径 (让用户使用)，在外存中的地址 (操作系统使用，对用户不可见)；
+ 其它信息
	+ 大小
	+ 创建时间，上次修改时间
	+ 文件所有者信息
+ 保护信息
	+ 对文件进行保护的访问控制信息 (权限)；
	+ 不同分组、不同用户的读写执行权限；

**向上提供的几个最基本的功能**
+ 创建文件 (create 系统调用)
+ 删除文件 (delete 系统调用)
+ 读文件 (read 系统调用)
+ 写文件 (write 系统调用)
+ 打开文件 (open 系统调用)
+ 关闭文件 (close 系统调用)

## 8.2 文件的逻辑结构
**什么是逻辑结构**
+ 所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的；
+ 而物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的；

**文件的逻辑结构**
+ 无结构文件
+ 有结构文件 
	+ 顺序文件 
	+ 索引文件
	+ 索引顺序文件

### 8.2.1 无结构文件
**无结构文件**
+ 概念：
	+ 文件内部的数据就是一系列二进制流或字符流组成。
	+ 又称为流式文件
+ 例如：    
	+ Windows 操作系统中的 `.txt` 文件；

### 8.2.2 有结构文件
**有结构文件**
+ 概念：
	+ 由一组相似的文件记录组成，又称记录式文件。
	+ 每条记录又若干个数据项组成。
+ 分类：
	+ 定长记录
	+ 可变长记录
+ 逻辑结构
	+ 顺序文件 
	+ 索引文件 
	+ 索引顺序文件 

### 8.2.3 顺序文件
**顺序文件**
+ 定义
	+ 文件中的记录一个接一个地顺序排列 (逻辑上)，记录可以是定长的或可变长的；
+ 存储形式
	+ 各个记录在物理上可以顺序存储或链式存储
+ 结构
	+ 串结构
		+ 记录之间的顺序与关键字无关
		+ 通常按照记录存入的时间决定记录的顺序
	+ 顺序结构
		+ 记录之间的顺序**按关键字顺序排列**；

**顺序文件存储**
+ 链式存储
	+ 无论是定长/可变长记录，都**无法实现随机存取**，每次只能从第一个记录开始依次往后查找；
+ 顺序存储 
	+ 可变长记录
		+ **无法实现随机存取**。每次只能从第一个记录开始依次往后查找；
	+ 定长记录
		+ **可实现随机存取**。记录长度为 L，则第 i 个记录存放的相对位置是 `i*L`
		+ 若采用串结构，无法快速找到某关键字对对应的记录
		+ 若采用顺序结构，可以快速找到某关键字对应的记录；
	+ 缺点：
		+ 增加、删除一个记录困难（除了串结构）
+ 结论：
	+ 定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；
	+ 若能再保证**记录的顺序结构**，则可实现快速检索 (即根据关键字快速找到对应记录 QS)； 
+ 注意：
	+ 一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件；

### 8.2.4 索引文件 
**索引文件**
+ 概念：
	+ 每个文件建立一个索引表，建立一张索引表以加快文件检索速度；
	+ 每条记录对应一个索引项；
	+ 索引表中的内容连续排列存放，但索引表记录的文件可以离散的存放；
	+ 每当要增加/删除一个记录时，需要对索引表进行修改；
+ 场合：
	+ 由于索引文件有很快的检索速度，因此主要用于**对信息处理的及时性要求比较高**的场合；
+ 查找：
	+ **索引表本身是定长记录的顺序文件**。因此可以**快速找到**第 i 个记录对应的索引项；
	+ 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字**折半查找**；
+ 缺点：
	+ 每个记录对应一个索引表项，因此索引表可能会很大；
+ 图示：
	+ ![[1712670421954.png]]

### 8.2.5 索引顺序文件 
**索引顺序文件**
+ 概念：
	+ 为文件建立一张索引表，但其不是每个记录对应一个索引表项，而是一组记录对应一个索引表项； 
	+ 索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入；
+ 举例：
	+ 问题：
		+ 若一个顺序文件有 10000 个记录，则根据关键字检索文件，只能从头开始顺序查找 (这里指的并不是定长记录、顺序结构的顺序文件)，平均须查找 5000 个记录；
	+ 分析：
		+ 若采用索引顺序文件结构，可把 10000 个记录分为 V 10000=100 组，每组 100 个记录； 
		+ 则需要先顺序查找索引表找到分组 (共 100 个分组，因此索引表长度为 100，平均需要查 50 次)，找到分组后，再在分组中顺序查找记录 (每个分组 100 个记录，因此平均需要查 50 次)；
		+ 采用索引顺序文件结构后，平均查找次数减少为 50+50=100 次；

**多级索引顺序文件**
+ 概念：
	+ 为了进一步提高检索效率，可以为顺序文件建立多级索引表
+ 举例：
	+ 对于一个含 $10^6$ 个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项 (即 10000 个定长记录)，再把这 10000 个定长记录分组，每组 100 个，为其建立顶级索引表，故顶级索引表中共有 100 个表项
+ 图示：
	+ ![[1712670925624.png]]

## 8.3 文件目录
### 8.3.1 文件控制块
**目录和文件控制块**
+ 引入：
	+ 目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件；
	+ 目录文件中的一条记录就是一个**文件控制块 (FCB)**
+ 文件控制块：
	+ 一个 FCB 就是一个文件目录项；
	+ FCB 的有序集合称为“文件目录”；
	+ FCB 中包含了文件的：
		+ 基本信息 (文件名、物理地址、逻辑结构、物理结构等)；
		+ 存取控制信息 (是否可读/可写、禁止访问的用户名单等)；
		+ 使用信息 (如文件的建立时间、修改时间等)
+ 文件控制块作用：
	+ FCB 实现了文件名和文件之间的映射；

**目录操作**
+ 搜索
	+ 当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项
+ 创建文件
	+ 创建一个新文件时，需要在所属的目录增加一个目录项
+ 删除文件
	+ 当删除一个文件时，需要在目录中删除相应的目录项
+ 显示目录
	+ 用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
+ 修改目录
	+ 某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项 (如: 文件重命名)

### 8.3.2 目录结构
 **单极目录结构**
+ 概念：
	+ 早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项；
	+ 在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中；
+ 特点：
	+ 1. 支持按名存取；
	+ 2. 不支持文件重命名；
	+ 3. 不适用于多用户系统；

**两级目录结构**
+ 概念：
	+ 早期的多用户操作系统，采用两级目录结构。
	+ 分为主文件目录 (MFD, Master File Directory)和用户文件目录 (UFD, User File Directory)。
	+ 两级目录结构**允许不同用户的文件重名**，也可以在目录上实现实现访问限制 (检查此时登录的用户名是否匹配)。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类；
+ 特点：
	+ 1. 允许不同用户的文件重名；
	+ 2. 用户不可以把自己的文件进行分类；
+ 图示：
	+  ![[1712672684419.png]]

**多级目录结构**
+ 概念：
	+ 又称树形目录结构
+ 特点
	+ 优点:
		+ 可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护；
	+ 缺点:
		+ 不便于实现文件的共享；
+ 路径：
	+ 绝对路径：从根目录开始；
	+ 相对路径：从当前目录出发的相对路径；
+ 图示：
	+ ![[1712672863163.png]]

**无环图目录结构**
+ 概念：
	+ 在多级目录结构基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图；
	+ 可以更方便地实现多个用户间的文件共享；
	+ 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录 (共享同一目录下的所有内容)
+ 共享计数器：
	+ 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录 (共享同一目录下的所有内容)；
	+ 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点； 
	+ 用户提出删除结点的请求时，只是删除该用户的 FCB、并使共享计数器减 1，并不会直接除共享结点；
	+ 只有共享计数器减为 0 时，才删除结点。


**注意**
+ 共享文件不同于复制文件。
+ 在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。

### 8.3.3 索引节点
**索引结点 (FCB 的改进)** 
+ 引入
	+ 只有文件名匹配时，才需读出文件的其他信息。因此可以考虑让目录表**瘦身**来提高效率；
+ 概念：
	+ 除了文件名之外的文件描述信息都放到索引节点当中，每一个文件都有一个唯一的索引结点；
	+ 只在文件名之外保留索引节点；
	+ 当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件；
+ 功能
	+ 存放在外存中的索引结点称为磁盘索引结点，当索引结点放入内存后称为内存索引结点。
	+ 相比之下内存索引结点中需要增加一些信息
		+ 比如：文件是否被修改，此时有几个进程正在访问该文件等

## 8.4 文件的物理结构
### 8.4.1 物理结构
**文件存储在外存**
+ 概念：
	+ 外存会分为一个个“块/磁盘块/物理块”；
	+ 很多操作系统中，磁盘块的大小与内存块、页面的大小相同；
	+ 每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址 (如。同样类似的是，文件的逻辑地本例中，一块包含 210 个地址，即 1 KB)
	+ 操作系统同样需要将逻辑地址转换为外存的物理地址 (物理块号，块内地址)的形式。块内地址的位数取决于磁盘块的大小；
+ 文件块： 
	+ 文件的逻辑地址空间被分为了一个一个的文件“块”；
	+ 文件的逻辑地址也可以表示为 $(逻辑块号，块内地址)$ 的形式；
	+ 文件系统分配空间也是以块为单位进行的；
+ 图示：
	+ ![[Pasted image 20240409205252.png]]

### 8.4.2 连续分配
**连续分配**
+ 定义
	+ 连续分配方式要求每个文件在磁盘上占有一组连续的块。
+ 地址：
	+ 用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项 (FCB)，计算：
	+ $$物理块号 = 起始块号 + 逻辑块号$$
	+ 当然，还需要检查用户提供的逻辑块号是否合法 (逻辑块号 $\geq$ 长度：不合法)
+ 特点
	+ 优点
		+ 1. 可以直接算出逻辑块号对应的物理块号；
		+ 2. 连续分配支持**顺序访问和直接访问 (随机访问)**；
		+ 3. 连续分配的文件在**顺序读/写**时速度最快；
	+ 缺点
		+ 1. 物理上采用连续分配的文件不方便拓展；
			+ 因为要连续的空间，因此经常会发生数据整体迁移，不方便拓展；
		+ 2. 存储空间利用率低，会产生难以利用的磁盘碎片
			+ 可以用紧凑来处理碎片，但是需要耗费很大的时间代价；
+ 图示：
	+ ![[Pasted image 20240409225448.png]]

### 8.4.3 链接分配
**链接分配**
+ 定义：
	+ 采用离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示链接两种。
+ 注意：
	+ 考试题目中遇到未指明隐式/显式的“链接分配”，默认指的是隐式链接的链接分配；
+ 隐式链接：
	+ 实现
		+ 除文件的最后一个盘块之外，每个盘块中都存有**指向下一个盘块的指针**；
		+ 文件目录包括文件第一块的指针和最后一块的指针；
	+ 特点
		+ 优点:
			+ 方便文件拓展； 
			+ 不会有碎片问题； 
			+ 外存利用率高；
		+ 缺点:
			+ 只支持顺序访问，不支持随机访问，查找效率低；
			+ 指向下一个盘块的指针也需要耗费少量的存储空间；
+ 显示链接：
	+ 实现
		+ 把**用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表** (FAT, File Allocation Table)；
		+ 一个磁盘仅设置一张 FAT 开机时，将 FAT 读入内存，并常驻内存；
	+ 特点
		+ 优点
			+ 很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问；
			+ 逻辑块号转换成物理块号的过程不需要读磁盘操作；
			+ 相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高；
		+ 缺点
			+ 文件分配表的需要占用一定的存储空间。
	+ 总结：
		+ 采用链式分配 (显式链接)方式的文件，支持顺序访问，也支持随机访问 (想访问 i 号逻辑块时，并不需要依次访问之前的 0~i-1 号逻辑块)；
		+ 由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多；
		+ 而且也不会产生外部碎片；
	+ 图示：
		+ ![[Pasted image 20240409235812.png]]

**注意**
+ 一个磁盘仅设置一张 FAT 开机时，将 FAT 读入内存，并常驻内存；
+ FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此**物理块号**字段可以是隐含的；

### 8.4.4 索引分配
**什么是索引分配**
+ 概念：
	+ 允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块；
	+ 索引表存放的磁盘块称为**索引块**。文件数据存放的磁盘称为**数据块**；
	+ 目录中需要记录文件的索引块是几号磁盘块；
+ 注意：
	+ 在显式链接的链式分配方式中，文件分配表 FAT 是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张；
	+ 逻辑块号可以是隐含的；
+ 实现：
	+ 从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只 i 号逻辑块在外存中的存放位置；
+ 特点：
	+ 索引分配方式可以支持随机访问；
	+ 索引分配中文件拓展也很容易实现 (只需要给文件分配一个空闲块，并增加一个索引表项即可)； 
+ 大文件处理：
	+ 1. 链接方案；
	+ 2. 多层索引；
	+ 3. 混合索引；
+ 图示：
	+ ![[Pasted image 20240410222050.png]]
	+ ![[Pasted image 20240410222035.png]]

**索引分配方案：链接方案**
+ 实现
	+ 如果索引表太大，一个索引块装不下，那么可以**将多个索引块链接起来存放**；
	+ 比如当前索引块最多可以有 256 个索引项，此时若文件的大小超过 256 个索引块可以支撑，则此时再分配一块索引块，用指针链接在一起；
	+ 想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块；
	+ 若想要访问文件的最后一个索引块，就必须找到最后一个索引块 (第 256 个索引块)，而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块
+ 特点
	+ 缺点
		+ 若文件很大，索引表很长，就需要将很多索引表链接起来。
		+ 想要找到 i 号索引块，必须先**依次读入 0~i-1 号**索引块，就导致吸盘 I/O 次数过多，查找效率低下。
+ 图示：
	+ ![[Pasted image 20240410222637.png]]

**索引分配方案：多层索引**
+ 实现
	+ 建立多层索引 (原理类似多级页表)。使第一层索引块指向第二层的索引块。
	+ 还可根据文件大小的要求再建立第三层，第四层索引块。
	+ 采用 K 层索引结构，且顶级索引表未调入内存，则**访问一个数据块只需要 K+1 次读磁盘操作**；
+ 特点
	+ `缺点:`
		+ 即使是小文件，访问一个数据块依然需要 K+1 次读磁盘。
+ 注意：
	+ 若采用多层索引，则各层索引表大小不能超过一个磁盘块；
+ 图示：
	+ ![[Pasted image 20240410223032.png]]

**索引分配方案：混合索引**
+ 实现
	+ 多种索引分配方式的结合。
	+ 例如：一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)，又包含一级间接索引(指向单层索引表)，还包含两级间接索引(指向两层索引表)；
+ 特点
	+ 优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少
+ 分析：
	+ 若顶级索引表还没读入内存访问 
	+ 0~7 号逻辑块: 两次读磁盘访问 
	+ 8~263: 三次读磁盘访问 
	+ 264~65799: 四次读磁盘
+ 图示：
	+ ![[Pasted image 20240410224117.png]]

### 8.4.5 总结
![[Pasted image 20240409205430.png]]

**考点**
+ ①要会根据多层索引、混合索引的结构计算出文件的最大长度 (Key: 各级索引表最大不能超过一个块);
+ ②要能自己分析访问某个数据块**所需要的读磁盘次数** (Key: FCB 中会存有指向顶级索引块的指针，因此可以根据 FCB 读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件--顶级索引块是否已调入内存)

## 8.5 文件存储空间管理
### 8.5.1 存储空间的划分与初始化
**基础概念**
+ 初始化：
	+ 存储空间的初始化：将各个文件卷划分为目录区、文件区
+ 文件卷：
	+ 将物理磁盘划分为一个个文件卷 (逻辑卷、逻辑盘)
	+ 有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷；
+ 目录区：
	+ 主要存放文件目录信息（PCB）、用于磁盘存储空间管理的信息；
+ 图示：
	+ ![[Pasted image 20240409205541.png]]

### 8.5.2 空闲表法
**空闲表**
+ 概念：回收
	+ 与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：
	+ 1. 回收区的前后都没有相邻空闲区；
	+ 2. 回收区的前后都是空闲区；
	+ 3. 回收区前面是空闲区；
	+ 4. 回收区后面是空闲区；
+ 适用：
	+ 适用于连续分配方式；
+ 图示：
	+ ![[Pasted image 20240410225253.png]]

### 8.5.3 空闲链表法
**两种方法**
+ 空闲盘块链
	+ 概念：
		+ 以盘块为单位组成一条空闲链；
		+ 操作系统保存着链头、链尾指针。
	+ 分配：
		+ 若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针；
	+ 回收：
		+ 回收的盘块依次挂到链尾，并修改空闲链的链尾指针；
	+ 图示：
		+ ![[Pasted image 20240410225625.png]]
+ 空闲盘区链
	+ 概念：
		+ 以盘区为单位组成一条空闲链，连续的空闲盘块组成一个空闲盘区；
		+ 空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针；
	+ 分配：
		+ 若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件；
		+ 若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据；
	+ 回收：
		+ 若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾；
	+ 适用范围：
		+ 离散分配、连续分配都适用；
		+ 为个文件分配多个盘块时效率更高；
	+ 图示：
		+ ![[Pasted image 20240410225644.png]]

### 8.5.4 位示图法
**位示图法**
+ 概念：
	+ 每个二进制位对应一个盘块；
	+ “0”表盘块空闲，“1”代表盘块已分配；
	+ 可以用 (字号，位号)对应一个盘块号
	+ $(字号, 位号)=(i, j)$ 的二进制位对应的盘块号 $b=ni+j$
	+ b 号盘块对应的字号 $i=b/n$，位号 $j=b mod(n)$
+ 分配：
	+ 若文件需要 K 个块：
	+ 1. 顺序扫描位示图，找到 K 个相邻或不相邻的“0”；
	+ 2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件；
	+ 3. 将相应位设置为“1” ；
+ 回收：
	+ ①根据回收的盘块号计算出对应的字号、位号;②将相应二进制位设为“0”
+ 适用范围： 
	+ 连续分配、离散分配都适配；
+ 注意：
	+ 盘块号、字号、位号到底是从 0 开始还是从 1 开始
+ 举例：
	+ 在本例中，“0”表盘块空闲“1”代表盘块已分配；
	+ 位示图一般用连续的“字”来表示，如本例中个字的字长是 16 位，**字中的每一位对应一个盘块**；
	+ 因此可以用 (字号，位号)对应一个盘块号。当然有的题目中也描述为 (行号，列号)
	+ ![[Pasted image 20240410230210.png]]

### 8.5.5 成组链接法
**成组链接法**
+ 引入：
	+ 空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX 系统中采用了成组链接法对磁盘空闲块进行管理；
+ 概念：
	+ 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致；
	+ 超级块类似于链头的作用，它永远保存了下一个分组的信息；
+ 回收：
	+ 举例：假设每个分组最多为 100 个空闲块，此时第一个分组已有 100 个块，还要再回收一块；
	+ 需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组；
+ 超级块构成：
	+ 1. 下一组空闲盘块数；
	+ 2. 空闲块号，链接上各个空闲块；
+ 图示：
	+ ![[Pasted image 20240410231144.png]]
	+ ![[Pasted image 20240410231257.png]]
   
## 8.6 文件的基本操作
### 8.6.1 创建文件
**Create 系统调用**
+ 参数
	+ 1. 所需的外存空间大小
	+ 2. 文件存放路径
	+ 3. 文件名
+ 实现
	+ 1. 在外存中找到文件所需的空间；
	+ 2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录文件中**创建该文件对应的目录项**；
		+ 目录项中包含了文件名，文件在外存中的存放位置等信息；

### 8.6.2 删除文件
**Delete 系统调用**
+ 主要参数
	+ 1. 文件存放路径
	+ 2. 文件名
+ 实现
	+ 1. 根据文件存放路径找到相应的目录文件，**从目录中找到文件名对应的目录项**；
	+ 2. 根据该目录记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块；
	+ 3. 从目录表中删除文件对应的目录项；

### 8.6.3 读文件
**Read 系统调用**
+ 补充：
	+ 读/写文件”用“文件描述符”即可指明文件，不再需要用到“文件名”；
+ 主要参数
	+ 1. 哪个文件 (索引号)
	+ 2. 读入多少数据
	+ 3. 读入的数据要放在内存中的什么位置
+ 实现
	+ 从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。
+ 注意: 
	+ 读/写文件用文件描述符，即可指明文件不再需要用到文件名；

### 8.6.4 写文件 
**Write 系统调用**
+ 主要参数
	+ 1. 哪个文件
	+ 2. 写出多少数据
	+ 3. 写回外存的数据放在内存中的什么位置
+ 实现
	+ 从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存；

### 8.6.5 打开文件
**open 系统调用**
+ 补充：
	+ 打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”；
+ 主要参数
	+ 1. 文件存放路径
	+ 2. 文件名
	+ 3. 要对文件的操作类型（如: r 只读，rw 读写等）
+ 实现
	+ 1. 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限；
	+ 2. 将目录项复制到内存中的**打开文件表**中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件；
+ 注意：  
	+ 打开文件不会把文件数据直接读入内存。而是将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号 (文件描述符)返回给用户
+ 打开文件表：
	+ 系统的打开文件表 (整个系统只有一张)
	+ 用户进程 A 的（打开文件表）
+ 图示：
	+ ![[Pasted image 20240409205742.png]]

### 8.6.6 关闭文件
**Close 系统调用**
+ 实现
	+ 1. 将进程的**打开文件表**相应表项删除（打开计数器为 0 时）
	+ 2. 回收分配给该文件的内存空间等资源
	+ 3. 系统打开文件表的打开计数器 count 减 1，若 count = 0，则删除对应表项


## 8.7 文件共享
### 8.7.1 硬链接
**基于索引结点的共享方式 (硬链接)**
+ 索引节点：
	+ 索引节点指针中存储指向索引节点的指针，索引节点中存储文件的物理地址；
	+ ![[Pasted image 20240410232941.png]]
+ 链接计数器：
	+ 链接计数变量 count，用于表示链接到本索引结点上的用户目录项数；
+ 删除：
	+ 若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的 count 值减 1。
+ 实现：
	+ 用户目录项指向同一个索引结点
	+ 索引结点中需要有链接计数 count
	+ 某用户想删除文件时，只是删除该用户的目录项，且 count--
	+ 只有 `count == 0` 时才能真正删除文件数据和索引结点，否则**会导致指针悬空**；
+ 图示：
	+ ![[Pasted image 20240410233036.png]]

### 8.7.2 软链接
**基于符号链接的共享方式 (软链接)**
+ 实现：
	+ 在一个 Link 型的文件中**记录共享文件的存放路径** (Windows 快捷方式)
	+ 操作系统**根据路径一层层查找目录**，最终找到共享文件；
+ 特征：
	+ 即使软链接指向的共享文件已经被删除，Link 型文件依然存在，只是通过 Link 型文件中的路径去查找共享文件会失败 (找不到对应目录项)
	+ 由于用软链接的方式访问共享文件要查询多级目录，会多次磁盘 I/O，因此用软连接访问；
+ 图示：
	+ ![[Pasted image 20240409205927.png]]

## 8.8 文件保护
### 8.8.1 口令保护
**口令保护**
+ 概念
	+ 为文件设置一个**口令**，用户请求访问该文件必须提供口令
	+ 口令一般存放在文件对应的 FCB 或索引结点中；
	+ 用户访问文件前需要先输入**口令**，操作系统会将用户提供的口令与 FCB 中存储的口令进行对比，如果正确，则允许该用户访问文件。
+ 特点
	+ 优点:
		+ 保存口令的空间开销不多； 
		+ 验证口令的时间开销也很小；
	+ 缺点:
		+ 正确的**口令**存在在系统内部，不够安全；


### 8.8.2 加密保护
**加密保护**
+ 定义
	+ 使用某个**密码**对文件进行加密，在访问文件时需要提供正确的**密码**才能对文件进行正确的解密；
	+ 如果使用错误的解压密码时，解密出来的文件是错误的；
+ 特点
	+ 优点:
		+ 保密性强，不需要在系统中存储**密码**
	+ 缺点:
		+ 编码/译码，或者说**加密/解码需要花费一定时间**; 
+ 图示：
	+ ![[Pasted image 20240412154218.png]]

### 8.8.3 访问控制
**访问控制**
+ 定义
	+ 在每个文件的 FCB (或索引结点)中增加一个访问控制列表 (Accrss-Control List, ACL)，该**表中记录了各个用户**可以对该文件执行哪些操作。
+ 精简的访问控制表：
	+ 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题；
	+ 精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。
	+ 如: 分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。
+ **访问类型**
	+ 读
		+ 从文件中读数据
	+ 写
		+ 向文件中写数据
	+ 执行
		+ 将文件装入内存并执行
	+ 添加
		+ 将新信息添加到文件结尾部分
	+ 删除
		+ 删除文件，释放空间
	+ 列表清单
		+ 列出文件名和文件属性
+ 特点
	+ 优点:
		+ 实现灵活，可以实现复杂的文件保护功能
+ 图示：
	+ ![[Pasted image 20240412154338.png]]
	+ ![[Pasted image 20240412154430.png]]


