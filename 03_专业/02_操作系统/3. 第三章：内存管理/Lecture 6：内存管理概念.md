---
title: Lecture 6：内存管理概念
tags:
  - 操作系统
  - 内存管理
categories: 
date: 2024-04-01
---
---
## 6.1 内存基础概念
### 6.1.1 什么是内存
**内存**
+ 概念：
	+ 是用于存放数据的硬件，程序执行前需要**先放到内存**中才能被 CPU 处理；
	+ 为了区分不同的程序、数据，需要为存储单元编其地址；
+ 存储单元：
	+ 内存中也有一个一个的“小房间”，每个小房间就是一个“存储单元”
	+ 如果计算机“按字节编址则每个存储单元大小为 1 字节，即 1 B，即 8 个二进制位；
	+ 如果字长为 16 位的计算机“按字编址”，则每个存储单元大小为 1 个字; 每个字的大小为 16 个二进制位；

**两种地址**
+ 相对地址
	+ 又称逻辑地址
+ 绝对地址
	+ 又称物理地址
+ 图示：
	+ ![[Pasted image 20240331165254.png]]

### 6.1.2 装入
**绝对装入** 
+ 概念：   
	+ 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生**绝对地址的目标代码**；
	+ 装入程序按照装入模块中的地址，将程序和数据装入内存；
	+ 编译、链接后得到的装入模块的指令直接就使用了绝对地址
+ 特点
	+ 只适用于**单道程序环境**；
	+ 缺乏平台独立性。依赖于其在具体平台的地址位置；

**静态重定位**  
+ 概念： 
	+ 又称可重装定位装入。
	+ 在**编译后**再将当前程序的地址填上合适的位置；
	+ 编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是**相对于起始地址而言的逻辑地址**。
	+ 可根据内存的当前情况，将装入模块装入到内存的适当位置。
	+ **装入时对地址进行重定位**，将逻辑地址变换为物理地址 (地址变换是在装入时一次完成的)
+ 特点
	+ 1. 在一个作业装入内存时，必须分配其要求的**全部内存空间**；
	+ 2. 如果没有足够的内存，就不能装入该作业；
	+ 3. 作业一旦进入内存后，在运行期间就**不能再移动**，也**不能再申请**内存空间；

**动态重定位**
+ 概念：
	+ 又称动态运行时装入。
	+ 编译、链接后的装入模块地址都是从 0 开始的；
	+ 装入程序把装入模块装入内存后、并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到**程序真正要执行时才进行**；
	+ 因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个 `重定位寄存器` 的支持。
+ 特点
	+ 1. 允许程序在内存中发生移动；
	+ 2. 可以把程序**分配到不连续的存储区**；
	+ 3. 程序运行前，只需要装入部分代码即可运行；
	+ 4. 运行时可以动态的申请分配内存；
	+ 5. 可以为用户提供一个比存储空间大的空间的地址空间；

### 6.1.3 链接
**链接的 3 种方式**
1. 静态链接：
	+ 在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件 (装入模块)，之后不再拆开；
2. 装入时动态链接：
	+ 将各目标模块装入内存时，边装入边链接的链接方式；
3. 运行时动态链接：
	+ 在程序执行中需要该目标模块时，才对它进行链接；
	+ 优点：便于修改和更新，便于实现对目标模块的共享；


## 6.2 内存管理基础概念
### 6.2.1 基础概念
**内存管理的功能**
+ 1. 操作系统负责**内存空间的分配与回收**
+ 2. 操作系统需要提供某种技术（虚拟化）从逻辑上**对内存空间进行扩充**；
+ 3. 操作系统需要提供功能，负责程序的地址转换（逻辑地址与物理地址的转换）；
+ 4. 操作系统需要提供**内存保护**功能。保证各进程在各自存储空间内运行，互不干扰；

### 6.2.2 内存保护
**什么是内存保护**
+ 防止 CPU 访问被禁止访问的区域；

**内存保护 2 种方法**
+ **方法一**
	+ 在 CPU 中设置一对**上、 下限寄存器**，存放进程的上，下限地址。
	+ 进程的指令要访问某个地址时，CPU 检查是否越界；
+ **方法二**
	+ 采用重定位寄存器(又称为基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查；
	+ 重定位寄存器中存放的是进程的起始物理地址；
	+ 界地址寄存器中存放的是**进程的最大逻辑地址**；
+ 图示：
	+ ![[Pasted image 20240331165452.png]]

### 6.2.3 进程的内存映像
**图示**
![[Pasted image 20240331191216.png]]

## 6.3 覆盖与交换
### 6.3.1 覆盖技术
**覆盖技术**
+ 思想
	+ 将程序分为多个段(多个模块)，常用的段常驻内存，不常用的段在**需要时调入内存**；
+ 内容
	+ 内存中分为**一个固定区和若干个覆盖区**；
	+ 需要常驻内存的段放在**固定区**中，调入后就不再调出 (除非运行结束)；
	+ 不常用的段放在**覆盖区**，需要用时调入内存，用不到时调出内存；
+ 特点
	+ 必须由**程序员声明覆盖结构**，操作系统完成自动覆盖；
	+ 覆盖技术只用于早期的操作系统中，现在已成为历史；
+ 缺点：
	+ 对用户不透明；
	+ 增加了用户编程负担；

### 6.3.2 交换技术
**交换 (对换)技术**
+ 思想
	+ 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些**已具备运行条件的进程换入内存** (进程在内存与磁盘间动态调度)；

**存放换出进程的位置**
+ 具有对换功能的操作系统中，通常把**磁盘空间**分为文件区和对换区两部分。
	+ 文件区
		+ 主要用于存放文件；
		+ 主要追求存储空间的利用率，因此对文件区空间的管理用**离散分配方式**；
	+ 对换区：
		+ 只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**；
		+ 由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常**对换区采用连续分配方式**；
+ 总结：
	+ 磁盘空间使用两种分区，对换主要使用对换区进行；
	+ 对换区的 I/O 速度比文件区的更快；

**什么时候应该交换**
+ 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停；

**应该换出哪些进程**
+ 1. 可优先换出**阻塞进程**；
+ 2. 可换出**优先级低**的进程；
+ 3. 为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑**进程在内存的驻留时间**...
+ **注意**：PCB 会常驻内存，不会被换出外存

**覆盖于交换的区别**
1. 覆盖是在同一个程序或进程中的；
2. 交换是在不同进程 (或作业)之间的；

## 6.4 连续分配管理方式
**两种分配方式**
+ 连续分配：指为用户进程分配的必须是一个连续的内存空间；
+ 非连续分配：为用户进程分配的不需要是一个连续的内存空间，可以是离散的；

**内部碎片与外部碎片**
+ 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上；
	+ 比如：采用固定分区分配，每个分区为 10 mb 大小。此时要分配一个 8 mb 的大小的空间，此时就需要为其分配一个 10 mb 大小的分区，因此产生了内部碎片；
+ 外部碎片：指内存中的某些空闲分区由于太小而难以利用 (紧凑技术解决)；
	+ 可以通过紧凑 (拼凑，Compaction)技术来解决外部碎片；

### 6.4.1 单一连续分配
**单一连续分配**
+ 概念：
	+ 单一连续分配方式中，内存被分为**系统区和用户区**；
	+ 系统区通常位于内存的低地址部分，用于存放操作系统相关数据；
	+ 用户区用于存放用户进程相关数据；
	+ 内存中**只能有一道用户程序**，用户程序独占整个用户区空间。
+ 分区
	+ 系统区：
		+ 通常位于内存的低地址部分，用于存放操作系统相关数据；
	+ 用户区：
		+ 用于存放用户进程相关数据；
+ 特点
	+ 优点：
		+ 实现简单；
		+ **无外部碎片**，可以采用覆盖技术扩充内存
		+ 不一定需要采取内存保护 (eg：早期的 PC 操作系统 MS-DOS)
	+ 缺点：
		+ 只能用于**单用户、单任务**的操作系统中
		+ **有内部碎片**（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片）；
		+ 存储器利用率极低
+ 补充：

### 6.4.2 固定分区分配
**固定分区分配**
+ 含义
	+ 为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**；
+ 分类
	+ 分区大小相等：
		+ 缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合
	+ 分区大小不等：
		+ 增加了灵活性，可以满足不同大小的进程需求。
		+ 根据常在系统中运行的作业大小情况进行划分。
+ 特点
	+ 优点：
		+ 实现简单，无外部碎片
	+ 缺点：
		+ 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；
		+ 会**产生内部碎片**，内存利用率低；

**分区说明表**
+ 概念
	+ 一种操作系统建立的数据结构，用于实现各个分区的分配与回收；
	+ 每个**表项对应一个分区**，通常按分区大小排列；
+ 功能
	+ 实现各个分区的分配与回收；
+ 内容
	+ 每个表项对应一个分区，通常按分区大小排列；
	+ 每个表项包括对应**分区的大小，起始地址，状态**(是否已分配)；
+ 图示：
	+ ![[Pasted image 20240331165746.png]]

### 6.4.3 动态分区分配
**动态分区分配（可变分区分配）**
+ 含义
	+ 不会预先划分内存分区，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要；
+ 特点：
	+ 系统分区的大小和数目是可变的； 
	+ 动态分区分配**没有内部碎片，但是有外部碎片**；

**空闲分区表与空闲分区链**
+ 空闲分区表：
	+ 概念：
		+ 每个空闲分区对应一个表项。表项中包含分区号、分区大小、分分区起始地址等信息；
	+ 注意：
		+ 各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定；
	+ 图示：
		+ ![[Pasted image 20240331195254.png]]
+ 空闲分区链：
	+ 概念：
		+ 每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息；
	+ 图示：
		+ ![[Pasted image 20240331195317.png]]

**空闲分区的分配方法：动态分区分配算法**
+ 把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表 (或空闲分区链)中选出一个分区分配给该作业；

## 6.5 动态分区分配算法
### 6.5.1 首次适合算法 
**首次适应算法 (First Fit)** 
+ 思想
	+ 每次都从**低地址**开始查找，找到第一个能满足大小的空闲分区；
+ 实现
	+ 空闲分区**以地址递增**的次序排列；
	+ 每次分配内存时顺序查找空闲分区链(或空闲分区表)，直到找到大小能满足要求的第一个空闲分区，将其分配给所需进程，然后修改当前表、链的空闲分区的大小数据；
+ 数据结构
	+ 空闲分区表
	+ 空闲分区链
+ 图示：
	+ ![[Pasted image 20240331165842.png]]

### 6.5.2 最佳适应算法
**最佳适应算法 (Best Fit)**  
+ 核心
	+ 优先使用**更小的空闲区**，尽可能多地留下大片的空闲区；
+ 思想
	+ 由于动态分区分配是一种连续分配方式，为各进程分配的空闲必须是连续的一整片区域；
	+ 因此为了保证当**大进程**到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即**优先使用更小的空闲区**；
+ 实现
	+ 空闲分区按**容量递增次序**链接；
	+ 每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的**第一个**空闲分区；
+ 特点
	+ 缺点
		+ 每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。
		+ 因此这种方式会**产生很多的外部碎片**；

### 6.5.3 最坏适应算法
**最坏适应算法 (Worst Fit)**  
+ 核心
	+ 每次分配时优先使用**最大的连续空闲区**；
+ 思想
	+ 为了解决最佳适应算法问题——即留下太多难以利用的小碎片
	+ 可以在每次分配时**优先使用最大的连续空闲区**，这样分配后剩余的空闲区就不会太小，更方便使用。
+ 实现
	+ 空闲分区按**容量递减次序**链接；
	+ 每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区；
+ 特点
	+ 缺点：
		+ 每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致**较大的连续空闲区被迅速用完**。
		+ 如果之后有**大进程**到达，就没有内存分区可用了。

### 6.5.4 邻近适应算法
**邻近适应算法 (Next Fit)**  
+ 核心
	+ 每次都**从上次查找结束的位置开始检索**；
+ 思想
	+ 其他的方法每次都从链头开始查找的，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销；
	+ 如果每次都从上次查找结束的位置开始检索，就能解决上述问题；
+ 实现
	+ 空闲分区以**地址递增的顺序排列** (可排成一个循环链表)；
	+ 每次分配内存时**从上次查找结束的位置开始**查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区；
+ 特点
	+ 优点
		+ 算法开销更小，空闲分区不需要按照空闲地址大小进行从大到小或从小到大的排列；
		+ 查找时间更小；
	+ 缺点
		+ 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区，都有相同的概率被使用；
		+ 也就导致了**高地址部分的大分区更可能被使用**，划分为小分区，最后**导致无大分区可用** (最大适应算法的缺点)

### 6.5.5 总结
**总结**：综合来看，4 种算法中，首次适应算法的效果反而更好；

![[Pasted image 20240331170005.png]]

## 6.6 基本分页存储管理
**内存空间的分配与回收**
+ 1. 连续分配管理方式 
	+ （1）单一连续分配
	+ （2）固定分区分配
	+ （3）动态分区分配
+ 2. 非连续分配管理方式
	+ （1）基本分页存储管理
	+ （2）基本分段存储管理
	+ （3）段页式存储管理

### 6.6.1 分页存储
**分页存储基础概念**
+ 概念：  
	+ 内存的页框：
		+ **将内存空间分为一个个大小相等的分区**，每个分区就是一个“页框”；
		+ 每个页框有一个编号，即“页框号”，页框号从 0 开始；
	+ 进程的**页面**与**页号**：
		+ 页面 `!=` 页号；
		+ 页号是对于页面的编号；
		+ 将**进程的**逻辑地址空间，也分为**与页框大小相等的一个个部分**；
		+ 每个部分称为一个“页”或“页面”。**每个页面也有一个编号，即“页号”**，页号也是从 0 开始；
	+ 页面与页框关系：
		+ 操作系统以页框为单位为各个进程分配内存空间；
		+ 进程的每个页面分别放入一个页框中；
		+ **进程的页面与内存的页框有一一对应的关系**；
+ 内容：
	+ 分区：
		+ 比如: 每个分区 4 KB
	+ 页框：
		+ $$页框=页帧=内存块=物理块=物理页面$$
	+ 页框号：
		+ $$页框号=页帧号=内存块号=物理块号=物理页号$$
+ 举例：
	+ 假设进程 A 大小为 23 MB，但是每个分区大小只有 10 MB，如果进程只能占用一个分区，那显然放不下。解决思路： 如果允许进程占用多个分区，那么可以把进程拆分成 10 MB+10 MB+3 MB 三个部分，再把这三个部分分别放到三个分区中 (这些分区不要求连续).
	+ 进程 A 的最后一个部分是 3 MB，放入分区后会产生 7 MB 的内部碎片。如果每个分区大小为 2 MB，那么进程 A 可以拆分成 11 X 2 MB+1 MB 共 12 个部分，只有最后一部分 1 MB 占不满分区，会产生 1 MB 的内部碎片。
	+ 结论：
		+ 如果把**分区大小设置的更小一些，内部碎片会更小，内存利用率会更高**；

### 6.6.2 页表
**页表**
+ 概念： 
	+ 为了能知道进程的**每个页面在内存中存放的位置**，操作系统要为每个进程建立一张**页表**；
+ 内容：
	+ 1. **一个进程对应一张页表**；
	+ 2. 进程的每个页面对应一个页表项；
	+ 3. 每个页表项由“页号”和“块号”**组成；
	+ 4. 页表记录**进程页面和实际存放的内存块**之间的映射关系
+ 页号与页块：
	+ 页号：
		+ 与进程逻辑地址空间一一对应；
	+ 块号：
		+ 和实际的内存当中的物理地址空间中的内存块号（页框号）一一对应；
+ 注意： 
	+ 页表通常存在 PCB (进程控制块)中；
+ 图示：
	+ ![[Pasted image 20240401204301.png]]

**页表项占字节数**
+ 举例：
	+ Eg: 假设某系统物理内存大小为 4 GB，页面大小为 4 KB，则每个页表项至少应该为多少字节? 
	+ 分析：$内存块大小=页面大小=4KB=2^{12}B$ 
	+ →4 GB 的内存总共会被分为 $2^{32}/2^{12}=2^{20}$ 个内存块
	+ →内存块号的范围应该是 $0\sim2^{20}-1$
	+ →内存块号至少要用 20 bit 来表示
	+ 即块号至少需要 3 个字节；
	+ 由于页表式隐含的，因此每个页表项站 3 B；
+ 注意： 
	+ 页表项连续存放，因此**页号可以是隐含的**，不占存储空间 (类比数组)；
	+ 假设页表中的各页表项从内存地址为 x 的地方开始连续存放：$i 号页表项的存放地址=X+3*$

**页表项大小探讨**
+ 概念： 
	+ 如果每个页表项占 4 字节，则每个页框刚好可存放 1024 个页表项；
	+ 1024 号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 $X+4*1024$ 得出；
+ 结论：
	+ 理论上，页表项长度为 3 B 即可表示内存块号的范围；
	+ 但为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页西恰好可以装得下整数个页表项；

### 6.6.3 逻辑地址转换
**地址转换方式**
+ 本质：
	+ 两次访问内存；
	+ 第一次：计算出页号，然后查页表；
	+ 第二次：根据页表得到信息，计算出物理地址，访问目标内存单元；
+ 计算方法：
	+ 假设要访问的逻辑地址 A：
	+ 1. 确定逻辑地址 A 对应的**页号** P； 
	+ 2. 找到 P 号**页号**在页表当中，对应的内存中的起始地址；
	+ 3. 确定逻辑地址 A 的“页内偏移量”W
	+ 4. 物理地址 = 页面始址 + 页内偏移量
+ 公式：物理地址计算 - 详细版
	+ $$逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W$$
+ 总结：
	+ 如果每个页面大小为 $2^{K}B$，用二进制表示逻辑地址，则末尾 K 即为页面偏移量，其余部分就是页号
	+ 因此如果让每个页面的大小为 2 的整数幂，计算机就可以很方便得出一个逻辑地址对应的页号和页内偏移量。

**物理地址计算**
+ $$\mbox{物理地址 = 页面始址 + 页内偏移量}$$
**页号**
+ $$\mbox{页号}= \frac{\mbox{逻辑地址}}{\mbox{页面长度}} \mbox{(取除法的}\textcolor{red}{\mbox{整数}}\mbox{部分)}$$
**页内偏移量**
+ $$\mbox{页内偏移量}= \mbox{逻辑地址} \% {\mbox{页面长度}} \ \mbox{(取除法的}\textcolor{red}{\mbox{余数}}\mbox{部分)}$$

**计算举例**
+ 举例：
	+ 在某计算机系统中，页面大小是 50 B。某进程逻辑地址空间大小为 200 B，则逻辑地址 110 对应的页号、页内偏移量是多少?
+ 计算： 
	+ ![[Pasted image 20240401205832.png]]

**二进制逻辑地址转换方式**
+ 页号：就是前面 20 位所表示的数值（假设位 32 位二进制表示）
+ 页内偏移：就是后 12 位二进制表示的数值（假设位 32 位二进制表示）
+ 结论：
	+ 如果每个页面的大小位 $2^k$ B，用二进制数表示逻辑地址时：末尾的 K 为为页内偏移量，其余部分为页号；
+ 优点： 
	+ 1. 计算方便；
	+ 2. 地址转换时，如果页面大小刚好是 2 的整数幂，则只需把页表中记录的**物理块号拼接上页内偏移量**就能得到对应的物理地址；
+ 图示：
	+ ![[Pasted image 20240331170433.png]]

### 6.6.4 逻辑地址结构
**逻辑地址结构**
+ 概念： 
	+ 地址结构包含两个部分:；
	+ 1. 前一部分为页号；
	+ 2. 后一部分为页内偏移量 W；
	+ 3. 若 K 位表示“页内偏移量”，则说明该系统中**一个页面的大小**是 $2^K$ 个内存单元
	+ 4. 若 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面
+ 图示：
	+ ![[Pasted image 20240401210542.png]]

### 6.6.5 基本地址变换机构
**页表寄存器**
+ 概念： 
	+ 通常会在系统中设置一个页表寄存器 (PTR)，存放页表在内存中的**起始地址 F** 和**页表长度 M**；

**基本地址变换机构**
+ 功能
	+ 基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址；
+ 使用
	+ 进程未执行时，页表的始址和页表长度放在进程控制块中； 
	+ 当**进程被调度**时，操作系统内核会把它们放到**页表寄存器中**；
+ 计算方法：
	+ 0. 假设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下： 
	+ 1. 计算页号 P 和页内偏移量 W (如果用十进制数手算，则 P=A/L，W=A%L; 但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)
	+ 2. 比较页号 P 和页表长度 M，若 PM，则产生越界中断，否则继续执行；
		+ 注意: 页号是从 0 开始的，而页表长度至少是 1，因此 P=M 时也会越界；
	+ 3. 页表中页号 P 对应的 $页表项地址=页表起始地址 F+页号 P*页表项长度$，取出该页表项内容 b 即为内存块号；
		+ 注意：区分页表项长度、页表长度、页面大小的区别；
		+ 页表长度指的是这个页表中总共有几个页表项，即总共有几个页；
		+ 页表项长度指的是每个页表项占多大的存储空间; 
		+ 页面大小指的是一个页面占多大的存储空间)
	+ 4. 计算 $E=b*L+W$，用得到的物理地址 E 去访存；
		+ 注意：如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了；
+ 计算图示：
	+ ![[Pasted image 20240331170605.png]]

**其他概念**
+ 页表长度
	+ 指的是这个页表中总**共有几个页表项**，即总共有几个页;
+ 页表项长度
	+ 指的是每个页表项占多大的存储空间；
+ 页面大小
	+ 指的是一个页面占多大的存储空间；
+ 页表项地址：
	+ $$\mbox{页表项地址}=\mbox{页表起始地址F}+\mbox{页号P}*\mbox{页表项长度}$$

**例题**
![[Pasted image 20240401213213.png]]

## 6.7 具有快表的地址变换机构
### 6.7.1 快表
**快表**
+ 概念： 
	+ 1. 又称联想寄存器 (TLB)；
	+ 2. 是一种访问速度比内存快很多的高速缓冲存储器，用来**存放当前访问的若干页表项**，以加速地址变换的过程；
	+ 3. 最近使用过的页表项会放入快表，**访问目标页表项时，先找快表**。如果快表中没有目标页表项，则需要查询内存中的页表；
+ 高速缓存：
	+ 高速缓存更适合配合 CPU 进行处理；
	+ 图示：
		+ ![[Pasted image 20240401233849.png]]
+ 注意： 
	+ 1. TLB 不等同于快速缓存。**TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本**；
	+ 2. 不能把整个页表都放入 TLB 中，因为 TLB 虽然快、但是贵、容量小；

**慢表**
+ 概念：内存中的页表常称为慢表；

### 6.7.2 快表的地址变换
**地址变换**
+ 本质：
	+ 在访问目标地址时，先查快表；
	+ 若在快表中查到，则直接在 TLB 中取出内存块号，然后访问内存 `->` 需要**访问一次**内存；
	+ 若未在快表中查到，则需要访问内存中的页表，找到页表项后将进行拼接得到物理地址，然后访问内存 `->` 需要**访问两次**内存；
+ 概念： 
	+ 1. CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较；
	+ 2. 如果找到匹配的页号：
		+ 要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此若快表命中，则访问某个逻辑地址仅需一次访存即可。
	+ 3. 如果在 TLB 中未匹配到页号：
		+ 需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址；
	+ 4. 访问该物理地址对应的内存单元；
		+ 若快表未命中，则访问某个逻辑地址需要两次访存 
	+ 注意：
		+ 在找到页表项后，应同时将其存入快表，以便后面可能的再次访问；
		+ 但若快表已满，则必须按照一定的算法对旧的页表项进行替换；
+ 优点： 
	+ 查询快表的速度比慢表快很多，只要 TLB 命中，则可以节省大量时间；
+ 快慢表同时查询：
	+ 图示：
	+ ![[Pasted image 20240401235222.png]]

**例题**
+ 题目：
	+ 某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1 us，访问一次内存耗时 100 us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少?
+ 计算： 
	+ 平均耗时：$(1+100)*0.9+(1+100+100)*0.1=111 us$

### 6.7.3 局部性原理
**局部性原理**
+ 时间局部性：
	+ 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；
	+ 如果某个数据被访问过，不久之后该数据很可能再次被访问；
		+ 因为程序中存在大量的循环；
+ 空间局部性：
	+ 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问；
		+ 因为很多数据在内存中都是连续存放的；

### 6.7.4 总结
![[Pasted image 20240401235439.png]]

## 6.9 两级页表
### 6.9.1 单级页表
**单极页表存在的问题**
+ 问题 1：
	+ 所有的页表项都连续存放的基础上才能找到页表项
	+ 因此当页表很大时，**需要用很多连续的页框**；
+ 问题 2：
	+ **没有必要让整个页表常驻内存**；
	+ 因为进程在一段时间内可能只需要访问某个特定的页面；

**解决思路**：把连续存放的页表再分页；
+ 概念： 
	+ 可将**长长的页表进行分组，使每个内存块刚好可以放入一个分组** (比如上个例子中，页面大小 4 KB, 每个页表项 4 B，每个页面可存放 1 K 个页表项，因此每 1 K 个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中)
	+ 另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表
### 6.9.2 两级页表
**页目录表**
+ 概念：
	+ 页目录表：
		+ 要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表;
	+ 二级页表：
		+ 每一个具体的页表；
+ 图示：
	+ 将页表，拆分成 `0#页表、1#页表、2#页表...1023#页表` 共 1024 个页表，每个页表 `4b` 一共 `1k` ；
	+ 10 位一级页号刚好可表示 0~1023
	+ ![[Pasted image 20240331170849.png]]

**注意事项**
+ 1. 若采用多级页表机制，则**各级页表的大小不能超过一个页面**；
	+ 举例：
		+ 问题：
			+ 某系统按字节编址，采用 40 位逻辑地址，页面大小为 4 KB，页表项大小为 4 B，假设采用纯页式存储，则要采用 ？级页表，页内偏移量为？位?
		+ 分析：
			+ 页面大小=4 KB=212 B，按字节编址，因此页内偏移量为 12 位页号=40-12=28 位页面大小=212 B，页表项大小=4 B，则每个页面可存放 212/4=210 个页表项
			+ 因此各级页表最多包含 210 个页表项，需要 10 位二进制位才能映射到 21 个页表项，因此每一级的页表对应页号应为 10 位。总共 28 位的页号至少要分为三级
		+ 图示：
			+ ![[1712062311930.png]]
+ 2. 两级页表的访存次数分析
	+ 第一次访存: 访问内存中的页目录表；
	+ 第二次访存: 访问内存中的二级页表；
	+ 第三次访存: 访问目标内存单元；
	+ 多了一次访存，相比于单级页表性能消耗更大；

### 6.9.3 二级页表的地址转换
**地址转换**
+ 方法：
	+ 1. 按照地址结构将逻辑地址拆分成三部分
	+ 2. 从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
	+ 3. 根据二级页号查表，找到最终想访问的内存块号
	+ 4. 结合页内偏移量得到物理地址
+ 举例：
	+ 问题：将逻辑地址 $(0000000000,0000000001,111111111111)$ 转换为物理地址 (用进制表示)；
	+ 解析：
		+ 一级页表：$0000000000$ `->` 页表： `0#` `->` 页表所在的内存块号：$3$
		+ ![[1712061585822.png]]
	+ 读出二级页表后，用二级页号读出内容：$0000000001$ `->` 在 4 号内存块 
		+ ![[1712061691002.png]]
	+ 计算物理地址：访问 4 号内存块 `->`  该内存块的起始地址为 $4*4096=16384$ `->` 加上业内偏移量 $111111111111$ `->` 最终物理地址 $16384+1023=17407$

## 6.10 基本分段存储管理方式
### 6.10.1 分段
**分段**
+ 概念： 
	+ 进程的地址空间按照程序自身的逻辑关系划分为若干个段；
	+ 每段都有一个**段名** (在低级语言中，程序员使用段名来编程)，每段从 0 开始编址；
+ 分配规则：
	+ 分段：
		+ 以**段为单位进行分配**，每个段在内存中占据连续空间，但各段之间可以不相邻；
	+ 段号：
		+ 又称之为段名。**段号的位数决定了每个进程最多可以分几个段**；
	+ 段内地址：
		+ 又称之为段内偏移量。**段内地址的位数决定了每个段的最大长度是多少**；
	+ 图示：
		+ ![[1712062591970.png]]
+ 特点
	+ 1. 按逻辑功能模块划分；
	+ 2. 用户编程更方便；
	+ 3. 程序的可读性更高；
+ 图示：
	+ ![[Pasted image 20240331170944.png]]

### 6.10.2 段表
**段表**
+ 作用：
	+ 程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找出个逻辑段的存放位置；
+ 概念： 
	+ 为每个进程建立一张段映射表，简称**段表**；
+ 组成：
	+ 1. 每个段对应一个**段表项**；
	+ 2. 段表项中记录了该段在内存中的**起始位置**(又称基址)和**段的长度**；
	+ 3. 各段表项的长度是相同的；
	+ 4. 段号可以是隐含的，不占存储空间。若段表存放的起始地址为 M，则 K 号段对应的段表项的存放的地址为 $M+K*6$
+ 图示：
	+ ![[1712063552598.png]]

**段表寻址过程**
+ 过程：
	+ 1. 根据逻辑地址得到：
		+ （1）段号；
		+ （2）段内地址；
	+ 2. 判断段号是否越界，若 `S≥M`，则产生越界中断，否则继续执行；
		+ 注意：段表长度至少是 1，而段号从 0 开始； 
	+ 3. 查询段表，找到对应的段表项，段表项的存放地址为 $F+S*段表项长度$；
	+ 4. 检查段内地址**是否超过段长**。若 `W>=C`，则产生越界中断，否则继续执行；
	+ 5. 计算得到物理地址
+ 物理地址计算：
	+ $$物理地址=段基址b+段内地址W$$

### 6.10.3 分段与分页比较
**分段与分页管理的对比**
+ 分页
	+ **页**是信息的物理单位。
		+ 分页的主要目的是为了实现离散分配，**提高内存利用率**；
		+ 分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的；
	+ 分页的用户进程地址空间是一维的：
		+ 程序员只需给出一个记忆符即可表示一个地址；
+ 分段
	+ **段**是信息的逻辑单位。
		+ 分段的主要目的是更好地满足用户需求；
		+ 一个段通常包含着一组属于一个逻辑模块的信息；
		+ 分段对用户是可见的，用户编程时需要显示地给出段名；
	+ 分段的用户进程地址空间是二维的：
		+ 程序员在标识一个地址时，既要给出段名，也要给出段内地址。 
+ 小结
	+ 结构
		+ 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
	+ 特点
		+ **分段比分页更容易实现信息的共享和保护**；
	+ 访存
		+ 分页 (单级页表)
			+ 第一次访存：查内存中的页表
			+ 第二次访存：访问目标内存单元。总共两次访存
		+ 分段
			+ 第一次访存：查内存中的段表
			+ 第二次访存：访问目标内存单元。总共两次访存
		+ 与分页系统类似，**分段系统中也可以引入快表机构**，将近期访问过的段表放到快表中，这样可以少一次访问，加快地址变换速度；

## 6.11 段页式管理方式
**分页与分段的优缺点分析**
+ 补充： 
	+ 分段管理中产生的外部碎片也可以用紧凑来解决，只是需要付出较大的时间代价；
+ 图示：
	+ ![[Pasted image 20240331171130.png]]

**段页式管理方式**
+ 组成
	+ 段号： 
		+ 位数决定了每个进程最多可以分几个段；
	+ 页号：
		+ 位数决定了每个段最大有多少页；
	+ 页内偏移量：
		+ 决定了页面大小，内存块大小是多少；
+ 地址结构
	+ 分段对用户是可见的，程序员编程时需要显式地给出段号，段内地址。而将各段**分页**对用户是不可见的。系统会根据段内地址自动划分页号和页内地址自动划分页号和页内偏移量。
	+ 因此段页式管理的地址结构是二维的。
+ 图示
	+ ![[1712064808298.png]]
+ 概念
	+ 段表
		+ 一个进程对应一个段表；
		+ 每个段对应一个段表项；
		+ 段表项长度相同，由段号 (**隐含**)，页表长度，页表存放地址组成；
	+ 页表
		+ 一个进程可以对应多个页表；
		+ 每个页对应一个页表项；
		+ 各页表项长度相同，由页号 (**隐含**)，页面存放的内存块号组成；
	+ 图示：
		+ ![[1712064965335.png]]
+ 图示：
	+ ![[Pasted image 20240331171231.png]]

**段页式管理的地址转换**：
1. 由逻辑地址得到段号，页号，页内偏移量
2. 段号与段表寄存器中的段长度比较，检查是否越界
3. 由段表始址，段号找到对应段表项
4. 根据段表中记录的页表长度，检查页号是否越界
5. 由段表中的页表地址，页号得到查询页表，找到相应页表项
6. 由页面存放的内存块号，页内偏移量得到最终的物理地址
7. 访问目标单元

