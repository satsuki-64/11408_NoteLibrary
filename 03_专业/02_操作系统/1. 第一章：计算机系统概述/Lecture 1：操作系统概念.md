## 1.1 操作系统基础概念
### 1.1.1 什么是操作系统
操作系统（Operating System, OS）：
- 是指控制和管理整个计算机系统的<硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境，它是计算机系统中**最基本**的<系统软件；

### 1.1.2 功能和目标
**操作系统的功能和目标：**
- 1. 作为系统资源的管理者：
	- 提供的功能：
		- 处理机管理 （CPU 调度）
		- 存储器管理
		- 文件管理
		- 设备管理（驱动）
	- 目标：
		- 安全，高效
- 2. 作为用户和计算机硬件之间的接口：
	- 提供的功能：
		- 命令接口
			- 联机命令接口：交互式命令接口
			- 脱机命令接口
		- 程序接口（使用 syscall）
			- 系统调用：程序 = 状态机 = 计算 -> syscall -> 计算 -> syscall 
		- GUI （图形用户界面）
	- 目标：
		- 方便用户使用
+ 3. **作为最接近硬件的层次**
	- 功能和目标：
		- 实现对硬件机器的拓展
	- 没有任何软件支持的计算机称为裸机
		- 在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强，使用更方便的机器
	- 通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机；

**注：关于用户接口** 
- 1. **命令接口：**
	- 允许用户<直接使用
	- **类别：**
		- 联机命令接口：用户说一句，系统做一句
			- =<交互式命令接口
		- 脱机命令接口：用户说一堆，系统做一堆
			- =<批处理命令接口
- 2. **程序接口：**
	- 允许用户通过程序<间接使用
	- 由一组<系统调用组成 （程序接口=系统调用）
	- **注：**
		- 系统调用=系统调用命令=广义指令
- 3. **GUI：**
	- 现在操作系统中最流行的<图形用户接口
	- 图形用户界面 （Graphical User Interface）
	- 例如：
		- Windows，安卓，ios，macOS 的图形化操作界面

## 1.2 操作系统的特征
### 1.2.1 并发
- 并发：
	- 指两个或多个事件在同一时间间隔内发生；这些事件**宏观上是同时发生的，但微观上是交替发生**的；
- 并行：
	- 指两个或多个事件在同一时刻同时发生；（**不是基本特征**）
- **操作系统的并发性：**
	- 指计算机系统中同时存在着多个运行着的程序；
- 一个单核处理机 （CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行
	- 操作系统和程序并发是一起诞生的
	- 并发性是通过分时实现

### 1.2.2 共享
- 共享：
	- 即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用；
- **两种共享方式**
	- **互斥共享方式：**
		- 系统中的某些资源，虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程**访问该资源；
	- **同时共享方式：**
		- 系统中的某些资源，允许一个时间段内由多个进程同时，对它们进行访问
+ 注意：
	+ 所谓的同时往往是宏观上的，而在微观上，这些进程可能是交替地对资源进行访问（即分时共享）
- 重点：
	- 并发性和共享性互为存在条件
	- **并发和共享是操作系统的最基本特征**
	+ 如果失去并发性，则当前 OS 当中只能有一个进程进行执行，此时共享性也就没有存在的意义；
	+ 如果失去了共享性，则当前 OS 当中多个程序也不能并发进入某区域；
### 1.2.3 虚拟
**虚拟**
- 指把一个物理上的实体变为若干个逻辑上的对应物；
- 物理实体 （前者）是实际存在的，而逻辑上对应 （后者）是用户感受到的；

**虚拟技术**
- 空分复用技术
	- 如：虚拟存储器技术
- 时分复用技术
	- 如：虚拟处理器

**没有并发性，虚拟性也就没有存在意义**

### 1.2.4 异步
**异步**
- 在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性；
- 只有系统有了并发性，才有可能导致异步性；

## 1.3 OS 的发展与分类
**发展阶段**
- 1. 手工操作阶段
	- **主要缺点：** 用户独占全机，人机速度矛盾导致资源利用率极低（大部分时间在空闲 OR 等待 IO 的状态）
- 2. 单道批处理阶段
	- 引入脱机输入/输出技术（用外围机，把程序提前存到磁带当中），并监督程序负责控制作业的输入，输出；
	- 磁带机编写好程序，自动的去读取数据；
- 3. 多道批处理系统 
	- 概念：
		- 正式诞生操作系统，用于支持多道程序的并发运行；
		- 每次往内存中读入多道程序，依次执行多道程序；
	- 主要优点：
		- 多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU 和其他资源更能保持“忙碌”状态，系统吞吐量增大。
- 4. 分时操作系统
	- 概念：
		- 计算机以**时间片**为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互
	- 主要优点：
		- 用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在；
	- 主要缺点：
		- 不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性；
- 5. 实时操作系统 
	- 概念：
		- 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性；
	- 优点：
		- 能够优先响应一些紧急任务，某些紧急任务不需时间片排队；
	- 两种操作系统
		- 1. 硬实时操作系统：必须在绝对严格的规定时间内完成处理；
		- 2. 软实时操作系统：能接受偶尔违反时间规定；
+ 6. 其他几种操作系统 （了解） 
	- **网络操作系统：**
		- 是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享 （如文件共享）和各台计算机之间的通信；
	- **分布式操作系统：**
		- **主要特点：**
			- 分布性和并行性
		- **简述：**
			- 系统中的台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行，协同完成这个任务；
	- **个人计算机操作系统：**
		- 如：Windows XP，MacOS，方便个人使用；


## 1.4 中断和异常
### 1.4.1 中断的概念
**中断的类型**
+ 1. 内中断 
	+ 别称：异常、例外
	+ 概念：
		+ 与当前**执行的指令有关**，中断信号来源于 CPU 内部
	+ 举例：
		+ 例子 1：试图在用户态下执行特权指令
		+ 例子 2：执行除法指令时发现除数为 0
		+ 例子 3：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令：**陷入指令**，该指令会引发一个内部中断信号；
+ 2. 外中断
	+ 别称：中断（狭义的中断）
	+ 概念：
		+ 与当前**执行的指令无关**，中断信号来自于 CPU 外部； 
	+ 举例：
		+ 例子 1：时钟中断；
			+ 时钟部件每隔一个时间片 (如 50 ms)会给 CPU 发送一个时钟中断信号，此时先暂停执行的程序，进入内核程序，处理中断程序（时钟中断），此时如果发现当前进程 1 的执行时间以及超过了时钟片的最大时长，则此时将程序的执行权切换为进程 2，交替进行执行；
		+ 例子 2：IO 中断
			+ 打印机完成打印之后，发送一个外中断，表示打印已经结束，可以结束任务；
+ 3. 注意：大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”

**陷入指令**
+ 概念：执行“陷入指令”意味着应用程序主动地将 CPU 控制权还给操作系统内核，系统调用就是通过陷入指令完成的； 
+ 注意：陷入指令是在**用户态**执行的，执行陷入指令之后立即引发一个内中断，使 CPU 进入核心态

**中断原语**
+ 陷入：trap
+ 故障：fault
	+ 比如缺页故障
+ 终止：abort
	+ 由致命错误引起，内核程序无法修复该错误，因此一般不再将 CPU 使用权还给引发终止的应用程序，而是直接终止该应用程序；
	+ 如：整数除 0、非法使用特权指令

### 1.4.2 中断的原理
**核心概念**
+ 不同的中断信号，需要用不同的中断处理程序来处理；
+ 1. 先需要检查中断信号：
	+ 对于内中断，CPU 在执行指令时会检查是否有异常发生；
	+ 对于外中断，CPU 会在每个指令周期的末尾检查是否有外中断信号需要处理；
+ 2. 找到相应中断处理程序：
	+ 当 CPU 检测到中断信号后，会根据中断信号的类型去查询“**中断向量表**”，以此来找到相应的中断处理程序在内存中的存放位置；
+ 中断向量表：
	+ ![[Pasted image 20240308145544.png]]

**中断机制的诞生：**
- **原因：**
	- 为了解决系统资源利用率低的问题
	- 为实现多道程序并发执行而引入的一种技术
- **本质：**
	- 发生中断就意味着需要操作系统介入，开展管理工作
	- 中断可以使 CPU 从用户态切换为核心态，使操作系统获得计算机的控制权；
		- 有了中断，才能实现多道程序[[1 - 2 操作系统的特征 1#并发|并发]]执行；

**中断的概念和作用：**
1. 当中断发生时，CPU 立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理


## 1.5 系统调用
### 1.5.1 系统调用基本概念
**系统调用**
- 是操作系统提供给应用程序 （程序员/编程人员）使用的接口；
- 一种可供内核外程序调用的系统指令，应用程序可以发出系统调用请求来获得操作系统的服务；

**系统调用的作用**
- 应用程序通过系统调用请求操作系统的服务；
- 系统中的**各种共享资源**都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作 （如存储分配，I/O 操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求；
- 这样可以保证系统的**稳定性和安全性**，防止用户进行非法操作；

**库函数和系统调用**
+ 操作系统内核对外面提供的 API 就是 Syscall，而当中和用户交互的就是 Shell。而在 Shell 的外面，OS 提供了一个框架性程序，帮助开发者实现应用程序（因为没有人愿意在没有库函数的情况下，直接使用汇编、系统调用来制作应用程序）
+ 在系统调用之上构建可以普遍使用的标准库：libc

### 1.5.2 系统调用的分类
**系统调用分类**
- 设备管理：
	- 完成设备的请求/释放/启动等功能
- 文件管理：
	- 完成文件的读/写/创建/删除等功能
- 进程控制：
	- 完成进程的创建/撤销/阻塞/唤醒等功能
- 进程通信：
	- 完成进程之间的消息传递/信号传递等功能
- 内存管理：
	- 完成内存的分配/回收等功能

**与库函数的区别**
- 不涉及系统调用的函数：
	- 如：取绝对值的函数
- 涉及系统调用的库函数：
	- 如：创建一个新文件的函数
+ 
### 1.5.3 过程
**系统调用背后的过程**
1. 传递系统调用参数，保存当前用户态进程的上下文环境；
2. 执行陷入指令，OS 进入内核态执行；
3. 系统根据进程上下文环境中，存储的寄存器数值，确定调用相应系统调用程序，当前 CPU 的执行流切换至处；
4. 返回用户程序，切换回用户态；

![[Pasted image 20230226163257.png|700]]

- **注意：**
	1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而 CPU进入核心态；
	2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行；
	3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令；

## 1.6 运行机制和体系结构
### 1.6.1 运行机制
- **指令：**
	- **特权指令：**
		- 如：内存清零指令
		- 不允许用户程序使用
	- **非特权指令：**
		- 如：普通的运算指令

**CPU 判断当前是否执行特权指令**
- **两种处理器状态：**
	- 用户态 （目态）：此时 CPU 只能执行非特权指令
	- 内核态（管态、核心态）：特权指令和非特权指令都可执行
- **具体操作：**
	- 用程序状态寄存器（PSW）中的某标志位来识别当前处理器处于什么状态
	- 如：1 为用户态，0 为核心态

**两种程序**
- **内核程序：**
	- 操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态；
- **应用程序：**
	- 为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态；

**用户态切换**（重要）
+ 内核态→用户态：
	+ 执行一条特权指令：**修改 PSW 的标志位为“用户态”**，这个动作意味着操作系统将主动让出 CPU 使用权；
	+ 更改标志位寄存器，在指令寄存器指向新的指令、指令进入解码器进行解码后，其中标志位取出，检测到 PSW（或其他体系结构上的对应符号）发生更改时，将内核态的栈保存，将程序的执行流切换至用户态程序的代码地址处，恢复用户态进程的执行环境，继续进行用户态进程执行；
	+ 更多的设计：
		+ CLR 中可以将进程设计为进程池、或者线程设计为线程池，同时进程池和线程池还分为用户态进程池、线程池和内核态进程池、线程池，在进行上下文切换时，只需要由系统自动激活某一个池中的进程、线程，减少上下文切换与进程开启的开销；
+ 用户态→内核态：
	+ 由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回 CPU 的使用权；
+ **发出**系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行

### 1.6.2 操作系统的内核 
**体系结构示意图**
+ ![[Pasted image 20240308152851.png]]

**层次结构构成**
- **内核**
	- 是计算机上配置的底层软件，是操作系统最基本，最核心的部分；
- **内核程序：**
	- 实现操作系统内核功能的那些程序就是内核程序；
- **操作系统内核模块**
	- 时钟管理：
		- 实现计时功能
	- 中断处理：
		- 负责实现中断机制
	- 原语
		- 是一种特殊的程序
		- 处于操作系统最底层，是最接近硬件的部分
		- 这种**程序的运行具有原子性**：其运行只能一气呵成，不可中断，即使有中断信号，也需要先执行完原语才可以进行中断；
		- **运行时间较短，调用频繁**；
- 其他模块 （有些操作系统不含有或更多）：
	- **对系统资源进行管理的功能：**
		- 进程管理
		- 存储器管理
		- 设备管理

### 1.6.3 操作系统的体系结构
**内容大纲**
+ 大内核
+ 微内核
+ 分层结构
+ 模块化
+ 外核


**两种操作系统体系结构的设计**
- **大内核**
	- 将操作系统的主要功能模块都作为系统内核，运行在核心态
		- 进程管理、存储管理、设备管理、时钟管理、中断处理、原语
	- 优点：
		- 高性能 -> 程序执行可能会进行**更多的上下文切换**（CPU 状态的转换）；
	- 缺点：
		- 内核代码庞大，结构混乱，难以维护
- **微内核：**
	- 只能把最基本的功能保留在内核
		- 时钟管理、中断处理、原语
	- 优点：
		- 内核功能少，结构清晰，方便维护
	- 缺点：
		- 需要频繁地在核心态和用户态之间切换，性能低
+ 图示
	+ ![[Pasted image 20230226134939.png|700]]

### 1.6.4 分层结构、模块化与外核
**总结**
![[Pasted image 20240308153456.png]]

**分层结构**
+ 分成不同的层次，最底层是硬件，最高层是用户接口；
+ 每层只可以调用相邻低层；
+ 优点：
	+ 1. 便于功能的调试与验证；
	+ 2. 以扩充和易维护，各层次之间的调用接口清晰；
+ 缺点：
	+ 1. 每层只可以调用相邻低层，难以定义边界；
	+ 2. 效率低，不能跨层调用，系统如果调用一个底层的指令，此时也得需要穿过所有层次；

**模块化**
+ 内核 = 主模块 + 可加载模块；
+ 主模块：进程模块、内存模块
+ 可加载模块：比如驱动程序
+ 优点：
	+ 1. 模块间结构清晰，可以多个模块并行的开发；
	+ 2. 支持**动态加载**新的内核模块 (如：安装设备驱动程序、安奘新的文件系统模块到内核)，增强 OS 适应性；
	+ 3. 任何模块都可以直接调用其他模块，**无需采用消息传递**进行通信，效率高；
+ 缺点：
	+ 1. 模块间相互依赖、难以验证；
	+ 2. 模块间的定义难以清晰；

**宏内核**
+ 所有的系统功能都放在内核里 (大内核结构的 OS 通常也采用了"模块化"的设计思想)； 
+ 优点：
	+ 1. 性能高，内核内部各种功能都可以直接相互调用；
+ 缺点：
	+ 1. 内核庞大功能复杂，难以维护；
	+ 2. 大内核中某个功能模块出错，就可能导致整个系统崩溃；

**外核**
+ 图示
	+ ![[Pasted image 20240308154209.png]]
+ 内外核：
	+ 1. 内核负责进程调度、进程通信等功能；
	+ 2. 外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全；
+ 举例：
	+ 有一些需要经常访问的硬件（内存区域），此时直接使用外核可以直接在硬件上分配连续的物理内存的地址空间，外存负责这个部分的访问安全；
+ 优点：
	+ 1. 外核可直接给用户进程分配"不虚拟、不抽象"的硬件资源，使用户进程可以更灵活的使用硬件资源；
	+ 2. 减少了虚拟硬件资源的“映射层"，提升效率；
+ 缺点：
	+ 1. 降低了系统的一致性；
	+ 2. 使系统变得更复杂；

## 1.7 操作系统的引导
**安装操作系统后**
+ 硬盘视角：
	+ 1. 主引导记录 （MBR）（包含：磁盘引导程序和分区表）
	+ 2. C 盘（活动盘）：
		+ 引导记录 PBR（负责找到“启动管理器）
		+ 根目录
		+ 其他
	+ 3. 其他盘
+ 主存视角：
	+ ROM（BIOS），包含 ROM 引导程序，即自举程序；
		+ BIOS 是由一系列程序构成，即使 CPU 断电，这其中的数据也不会丢失；
	+ RAM：内存

**OS 启动执行**
+ 1. BIOS 读取硬盘 MBR 中的数据，读取 
	+ 1. 磁盘引导程序；
	+ 2. 分区表；
+ 2. 将这些数据加载到 RAM 中；
+ 3. CPU 执行 RAM 中已经读取到的程序，根据读取的分区表的数据，找到 C 盘位置；
+ 4. 读取 C 盘中的 PBR 数据，找到启动管理器（在根目录下的某个位置）；
+ 5. CPU 执行启动管理器中的启动管理程序；

**另一种表述**
操作系统引导:
1. CPU 从一个特定主存地址开始 > 取指令，执行 ROM 中的引导程序 （先进行硬件自检，再开机） ； 
2. 将磁盘的第一块：主引导记录读入内存，执行磁盘引导程序，扫描分区表； 
3. 从活动分区 (又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序； 
4. 从根目录下找到完整的操作系统初始化程序 (即启动管理器)并执行，完成“开机”的一系列动作； 

## 1.8 虚拟机
**什么是虚拟机**
+ 虚拟机 
	+ 使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器 (VirtualMachine, VM)，每个虚拟机器都可以独立运行一个操作系统；
+ 同义术语：虚拟机管理程序/虚拟机监控程序/irtualMachine Monitor/Hypervisor；

**两类虚拟机图示**
+ 第一类 VMM
	+ ![[Pasted image 20240308160328.png]]
	+ 上层的操作系统：运行在用户态，其中的内核空间为虚拟内核空间，其中的特权指令需要经过 VM 进行转化，才可以变成内核空间中的内核指令；
	+ 第一类虚拟机管理程序：运行在内核态；
+ 第二类 VMM 
	+ ![[Pasted image 20240308160356.png]]
	+ 第二类虚拟机管理程序：运行在用户态上，其如果需要使用特权指令，也需要向宿主操作系统进行申请；

**两类虚拟机架构对比**
+ 资源分配方式
	+ VMM 1：需要在原本的硬盘上直接进行物理的分配，类似于外核的分配方式，分配的是物理内存；
	+ VMM 2：虚拟机向宿主操作系统申请一个大文件，是 Host OS 为其分配的一个虚拟内存；
+ 性能
	+ VMM 1：性能更好；
	+ VMM 2：性能更差，需要 Host OS 进行上下文转换；
+ 可支持的虚拟机数量
	+ VMM 1：可以支持更多的虚拟机；
	+ VMM 2：更少；
+ 虚拟机的迁移程序：
	+ VMM 1：迁移起来更麻烦；
	+ VMM 2：迁移起来很简单，直接打把票成 `iso` 文件；
+ 运行模式：
	+ VMM 1：第一类 VMMI 运行在最高特权级 (Ring 0)，可以执行最高特权的指令；
	+ VMM 2：部分运行在用户态、部分运行在内核态。GuestOS 发出的系统调用会被 VMM 截获, 并转化为 VMM 对 Hostos 的系统调用；
+ 图示：
	+  ![[Pasted image 20240308160803.png]]