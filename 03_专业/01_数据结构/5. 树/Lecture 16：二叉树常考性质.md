---
title: Lecture 16：二叉树常考性质
tags:
  - 数据结构
  - 二叉树
categories: 
date: 2024-03-27
---
---
## 16.1 二叉树的定义和基本术语
### 16.1.1 二叉树的基本概念
**基本概念**
+ 二叉树是 $n(n\geq 0)$ 个结点的有限集合：
+ 两种二叉树
	+ 1. 或者空二叉树，即 $n=0$
	+ 2. 或者由一个根节点和两个**互不相交**的被称为根的左子树和右子树分成两棵二叉树
+ **特点：**
	+ 1. 每个结点至多只有两棵子树；
	+ 2. 左右子树不能颠倒 (二叉树是有序树)；
	+ 3. 度为 2 的有序树：在这棵树里面至少有一个结点它的度为 2，而二叉树无要求；
+ 图示：
	+ ![[Pasted image 20240326222736.png]]

### 16.1.2 常见二叉树
**满二叉树** 
+ 概念：一颗高度为 h，且含有 $2^{h}-1$ 个结点的二叉树
+ **特点：** 
	+ 1. 只有最后一层有叶子节点；
	+ 2. 不存在度为 1 的结点；
	+ 3. 按层序从 1 开始编号，结点 i 的左孩子为 2 i，右孩子为 2 i+1。结点 i 的父节点为 $\lfloor \frac{i}{2} \rfloor$ (`向下取整`) (如果有的话)；
+ 图示：
	+ ![[Pasted image 20240326222802.png]]

**完全二叉树：** 
+ 概念：当且仅当每个结点都与高度为 h 的满二叉树中编号为 $1\sim n$ 的结点一一对应时，称为完全二叉树
+ **特点：**
	+ 1. 只有最后两层可能有叶子结点
	+ 2. 最多只有一个度为 1 的结点
	+ 3. 按层序从 1 开始编号，结点 i 的左孩子为 2 i，右孩子为 2 i+1。结点 i 的父节点为 $\lfloor \frac{i}{2} \rfloor$ (`向下取整`) (如果有的话)；
	+ 4. $i\le \lfloor \frac{n}{2} \rfloor$ 为**分支结点**，$i>\lfloor \frac{n}{2} \rfloor$ 为**叶子节点**
	+ 5. 如果某个结点只有一个孩子那么一定是**左孩子**（**因为顺序编号**）(**偶数**)
+ 解释：即如果按照满二叉树排列后，按照从大到小的数字进行删除，删除后的树为完全二叉树；

**二叉排序树：**  
+ 用途：二叉树可以用于元素的排序，搜索
+ 特征：
	+ 1. **左子树**上所有结点的**关键字**均小于根节点的关键字；
	+ 2. **右子树**上所有结点的**关键字**均大于根节点的关键字；
	+ 3. **左子树和右子树又各是一棵二叉排序树**；
+ 图示：
	+ ![[Pasted image 20240326222902.png]]

**平衡二叉树：**
+ 树上任一结点的**左子树**和**右子树**的深度之差不超过 1；

## 16.2 二叉树的性质
### 16.2.1 二叉树的常考性质
**考点 1：** 设非空二叉树度为 0，1 和 2 的结点个数分别为 $n_{0},n_{1}$ 和 $n_{2}$，
+ 结论：$n_{0}=n_{2}+1$
+ **叶子结点比二分支结点多一个**
+ 推导：
	+ $\begin{array}{c}\mathrm{n}=n_0+n_1+n_2\\\mathrm{n}=n_1+2n_2+1\end{array}$
	+ 第一个公式：$\mathrm{n}=n_0+n_1+n_2$  `->` 节点个数 = `度为0节点数` + `度为1节点数` + `度为2节点数`；
	+ 第二个公式：$\mathrm{n}=n_1+2n_2+1$ `->` 节点个数 = 总度数 + 1 = （`度为1节点数` + `与之相连的度为2的节点数` + 1 个根节点）；
	+ 带入解出：$n_{0}=n_{2}+1$

**考点 2：** 每层节点数
+ 二叉树第 i 层**至多**有 $2^{i-1}$ 个结点 ($i\geq 1$)
+ $m$ 叉数第 i 层**至多**有 $m^{i-1}$ 个结点 ($i\geq 1$)

**考点 3：**
+ 高度为 h 的二叉树至多有 $2^{h}-1$ 个结点 (**满二叉树**)
+ 高度为 h 的 m 叉树至多有 $\frac{m^h-1}{m-1}$ 个结点

### 16.2.2 完全二叉树的常考性质
 **考点 1：** 具有 n 个 ($n>0$)结点的完全二叉树的高度 h 为
+ 高度 h =  $\lceil \log_{2}(n+1)\rceil\mbox{或}\lfloor \log_{2}n\rfloor +1$；
+ 注意：一个是和上层比较，一个和下次比较，所以不同

**考点 2：** 对于完全二叉树，可以由结点数 n 推出为 0，1 和 2 的结点个数为 $n_{0},n_{1}$ 和 $n_{2}$
+ 完全二叉树最多只有一个度为 1 的结点，即：
	+ $n_{1}=0\mbox{或}1$
	+ $n_{0}=n_{2}+1 \to n_{0}+n_{2}\mbox{一定是奇数}$ 
+ **推导：**
	+ 若完全二叉树有 2 k 个 (**偶数**)个结点，则必有 $n_{1}=1,n_{0}=k,n_{2}=k-1$
	+ 若完全二叉树有 2 k-1 个 (**奇数**)个结点，则必有 $n_{1}=0,n_{0}=k,n_{2}=k-1$

**完全二叉树性质补充：**
+ 1. 当 $i>1$ 时，结点 $i$ 的双亲编号为 $\lfloor \frac{i}{2}\rfloor$
	+ 当 $i$ 为偶数时，其双亲的编号为 $\frac{i}{2}$，它是双亲的左孩子
	+ 当 $i$ 为奇数时，其双亲的编号为 $\frac{i-1}{2}$，它是双亲的右孩子
+ 2. 当 $2i\le n$ 时，结点 $i$ 的左孩子编号为 $2i$，否则无左孩子。
+ 3. 当 $2i+1\le n$ 时，结点 $i$ 的右孩子编号为 $2i+1$，否则无右孩子。
+ 4. 结点 $i$ 所在层次 (**深度**)为 $\lfloor \log_{2}i\rfloor+1$。

## 16.3 二叉树的存储结构
### 16.3.1 顺序存储
**什么是顺序存储**
+ 结论：
	+ 二叉树的顺序存储结构，只适合存储**完全二叉树**；
+ 概念：
	+ 定义一个长度为 MaxSize 的数组 t，按照**从上至下**，**从左至右**的顺序依次存储[[5 + 2 + 1 二叉树的定义和基本术语#^mk-202301092235|]]中的各个结点；
+ 注意： 
	+ 非完全二叉树不能通过 i 和 n 的比较来判断是否为左右结点 (因为不满)，只能用 isEmpty 来判断
+ 初始化：
	+ `for(int i=0;i<Maxsize;i++)`
	+ ![[Pasted image 20240326223304.png]]
+ 基本操作：
	+ `i` 的左孩子：`2i`
	+ `i` 的右孩子：`2i+1`
	+ `i` 的父节点：$\left\lfloor i/2\right\rfloor$
	+ `i` 所在的层次：$\lceil\log_2(n+1)\rceil\text{或}\lfloor\log_2n\rfloor+1$
+ 基本判断操作：
	+ 判断 i 是否有左孩子：`2i≤n`
	+ 判断 i 是否有右孩子：`2i+1≤n`
	+ 判断 i 是否是叶子/分支结点：`i>[n/2]`
+ 完全二叉树： 
	+ ![[Pasted image 20240327213205.png]]

**非完全二叉树**
+ 概念：
	+ 1. 非完全二叉树的节点编号无法和节点连续起来；
	+ 2. 所以在二叉树的顺序存储中，一定要把**二叉树的结点编号与完全二叉树对应**起来；
+ 非完全二叉树的判断操作 `->` 无法判断，需要使用 `isEmpty` 属性来判断；
+ 图示：
	+ ![[Pasted image 20240326223311.png]]

**代码实现**
```c
#define MaxSize 100
struct TreeNode{
	ElemType value;  //结点中的数据元素
	bool isEmpty;    //结点是否为空
}

//初始化数组 TreeNode t[MaxSize];
```

### 16.3.2 链式存储
**什么是链式存储**
+ 注意：n 个结点，就有 2 n 个指针域，n-1 个指针指向一个结点 (根节点排除)，即两者相减得到空链域 (可以用于构造线索二叉树)
+ 图示：
	+ ![[Pasted image 20240326223421.png]]

**代码实现**
+ 节点定义：
```c
//二叉树的结点(链式存储)
typedef struct BiTNode{
	ElemType data;                  //数据域
	struct BiTNode *lchild,*rchild; //左，右孩子指针
}BiTNode,*BiTree;
```
+ 链式树：
```c
//二叉树的链式构建
struct ElemType{
	int value;
};
typedef struct BiTNode{
	ElemType data;
	struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

//定义一棵空数(root指向根节点)
BiTree root = NULL;

//插入根节点
root = (BiTree)malloc(sizeof(BiTNode));
root->data = {1};
root->lchild = NULL;
root->rchild = NULL;

//插入新结点
BiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));
p->data = {2};
p->lchild = NULL;
p->rchild = NULL;
root->lchild = p;  //作为根节点的左孩子
```

**三叉链表**
+ 概念：除了左右子节点外，还多一个指向父节点的指针；
+ 目的：方便找父结点；
+ 注意：但是考研中喜欢考不带 parent 的方式
+ 代码：
```c
//二叉树的结点(链式存储)
typedef struct BiTNode{
	ElemType data;                  //数据域
	struct BiTNode *lchild,*rchild; //左，右孩子指针
	struct BiTNode *parent;         //父节点指针
}BiTNode,*BiTree;
```